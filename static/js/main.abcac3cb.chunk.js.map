{"version":3,"sources":["AnalysisWorker.js","worker.js","store/actions.js","components/InputDataUpload.js","RunAnalysis.js","components/InputReplicateSelection.js","analysis/utils.js","analysis/Imputation.js","analysis/MSExperiment.js","components/InputImputation.js","components/InputComparisonSelection.js","components/InputContainer.js","Figures.js","components/MainPanelContainer.js","components/SidePanelContainer.js","components/FigureOptions.js","components/ViewContainer.js","components/App.js","store/store.js","index.js"],"names":["worker","wrap","Worker","ACTIONS","createAction","type","data","connect","dispatch","onDataUpload","file","Response","arrayBuffer","then","ab","transfer","getSamples","samples","htmlFor","id","name","onInput","e","target","files","Modal","setAppElement","state","input","onReplicatesSelect","conditions","Object","keys","React","useState","replicatesModalOpen","setReplicatesModalOpen","selectedReplicates","setSelectedReplicates","conditionName","setConditionName","setConditions","onClick","isOpen","style","overlay","zIndex","multiple","onChange","Array","from","selectedOptions","map","opt","value","sample","length","assign","margin","entries","condition","replicates","join","pAdjust","pvalues","p","index","sort","a","b","i","padj","Math","min","entry","imputeUniform","DataFrame","columns","MSExperiment","COMMON_COLUMNS","reduce","obj","column","getSeries","series","where","Number","isNaN","bake","mean","average","stdev","std","select","random","uniform","getIndex","imputeConditionRelative","corrCache","Map","corr","s1","s2","has","tuple","get","arr1","toArray","arr2","arrNaN","c","jstat","corrcoeff","filter","v","max","set","deltaCache","delta","deltas","res","samplesByNumNotNaN","val","sum","imputedRelative","row","refSample","values","acc","s","meanCorr","Dmean","Dstd","Dnew","normal","sqrt","abs","imputedUniform","subset","zip","rowRel","rowUnif","every","imputeRelative","columnSpec","forEach","m","result","getColumns","this","rawData","snapshots","comparisons","removeContaminants","bind","logTransform","removeAllNaN","setReplicates","key","console","log","SNAPSHOT_KEYS","REMOVE_CONTAMINANTS","log2","NaN","LOG_TRANSFORM","normalize","medians","median","maxMedian","apply","MEDIAN_NORMALIZATION","clear","method","IMPUTATION_METHODS","METHOD_31","Imputation","METHOD_46","METHOD_47","IMPUTE_MISSING_VALUES","conditionA","conditionB","comparisonData","arrA","arrB","meanA","meanB","pvalue","m1","m2","se","pow","df","floor","t","studentt","cdf","ttest","withSeries","withIndex","Series","onImputeClick","options","onImpute","imputationModalOpen","setImputationModalOpen","setOptions","checked","currentTarget","onComparisonSelect","comparisonsObj","onComparisonsSelect","comparisonModalOpen","setComparisonModalOpen","selected","Set","add","delete","onComparisonChange","disabled","InputContainer","className","FIGURES","LOG_VIOLIN","PRE_POST_IMPUTATION_VIOLIN","PRE_POST_IMPUTATION_BOXPLOT","VOLCANO","P_VALUE_HISTOGRAM","makePlotlyDataLayout","ret","layout","makeLogViolin","makePrePostImputationViolin","makePrePostImputationBoxplot","makeVolcanoPlot","makePValueHistogram","autosize","makeViolinTrace","trace","width","points","undefined","Promise","all","getData","x","y0","side","getReplicates","array","flat","title","showlegend","xaxis","yaxis","automargin","legendgroup","makeBoxplotTrace","y","x0","boxmode","boxgap","boxgroupgap","highlightGenes","highlightGeneSet","g","toLowerCase","getComparisonData","logfc","genes","mode","log10","hovertext","marker","color","start","end","size","opacity","xbins","barmode","figureOptions","view","plot","setPlot","useEffect","useResizeHandler","height","divId","setData","getComparisonsTable","selectableRows","figureType","onOptionsChange","sampleCondition","setSampleCondition","onFigureTypeChange","JSON","parse","stringify","placeholder","split","onOptionsSet","onDownloadClick","downloadData","blob","Blob","link","document","createElement","href","window","URL","createObjectURL","download","click","onSavePlotClick","Plotly","downloadImage","format","filename","setFigureOptions","defaultValue","fig","changedOptions","App","initialState","main","inputReducer","action","viewReducer","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","cpy","applyMiddleware","thunk","ReactDOM","render","StrictMode","store","getElementById"],"mappings":"uWAMeA,EADAC,YAAK,ICLL,WACb,OAAO,IAAIC,OAAO,IAA0B,yCCDjCC,EACU,oBADVA,EAEa,uBAFbA,EAGc,wBAHdA,EAIgB,0BAGtB,SAASC,EAAaC,EAAMC,GAC/B,MAAO,CACHD,OACAC,Q,sBCgBOC,kBAAQ,MAAM,SAACC,GAC1B,MAAO,CACHC,aAAc,SAACC,GACXF,ECjBL,SAAsBE,GACzB,OAAO,SAACF,GACJ,IAAIG,SAASD,GAERE,cAEAC,MAAK,SAACC,GACH,OAAOd,EAAOS,aAAaM,YAASD,EAAI,CAACA,QAG5CD,MAAK,WACF,OAAOb,EAAOgB,gBAGjBH,MAAK,SAACI,GACHT,EAASJ,EAAaD,EAA2Bc,QDE5CR,CAAaC,QAHnBH,EAvBf,YAA4C,IAAjBE,EAAgB,EAAhBA,aACvB,OACI,gCACI,wBAAOS,QAAQ,aAAf,+CACuC,OAEvC,uBACIb,KAAK,OACLc,GAAG,aACHC,KAAK,aACLC,QAAS,SAACC,GAAD,OAAOb,EAAaa,EAAEC,OAAOC,MAAM,OAGhD,6BACI,4H,0CEVhBC,IAAMC,cAAc,SA4GLnB,mBACX,SAACoB,GACG,MAAO,CACHV,QAASU,EAAMC,MAAMX,YAG7B,SAACT,GACG,MAAO,CACHqB,mBAAoB,SAACC,GACjBtB,ED5FT,SAA4BsB,GAC/B,OAAO,SAACtB,GAEJR,EAAO6B,mBAAmBC,GAAYjB,MAAK,WAEvCL,EACIJ,EACID,EACA4B,OAAOC,KAAKF,SCoFPD,CAAmBC,QAT7BvB,EA1Gf,YAAmE,IAAhCU,EAA+B,EAA/BA,QAASY,EAAsB,EAAtBA,mBAAsB,EACRI,IAAMC,UAAS,GADP,mBACvDC,EADuD,KAClCC,EADkC,OAEVH,IAAMC,SAAS,IAFL,mBAEvDG,EAFuD,KAEnCC,EAFmC,OAGpBL,IAAMC,SAAS,IAHK,mBAGvDK,EAHuD,KAGxCC,EAHwC,OAI1BP,IAAMC,SAAS,IAJW,mBAIvDJ,EAJuD,KAI3CW,EAJ2C,KAqB9D,OACI,gCACI,wCACA,wBAAQC,QAAS,kBAAMN,GAAuB,IAA9C,+BAIA,6BACI,yHAMJ,eAAC,IAAD,CACIO,OAAQR,EACRhB,GAAG,wBACHyB,MAAO,CACHC,QAAS,CACLC,OAAQ,MALpB,UASI,oBAAI3B,GAAG,6BAAP,+BAEA,sBAAKA,GAAG,6BAAR,UACI,yDACA,wBACI4B,UAAQ,EACRC,SAAU,SAAC1B,GACPgB,EACIW,MAAMC,KAAK5B,EAAEC,OAAO4B,iBAAiBC,KACjC,SAACC,GAAD,OAASA,EAAIC,WAL7B,SAUKrC,EAAQmC,KAAI,SAACG,GAAD,OACT,wBAAQD,MAAOC,EAAf,SACKA,GADuBA,WAOxC,gCACI,mFACA,uBAAOrC,QAAQ,gBAAf,8BACA,uBACIb,KAAK,OACLc,GAAG,gBACHC,KAAK,gBACLkC,MAAOf,EACPS,SAAU,SAAC1B,GAAD,OAAOkB,EAAiBlB,EAAEC,OAAO+B,UAE/C,uBACA,wBAAQZ,QAvED,WACU,IAAzBH,EAAciB,SAClBf,EACIV,OAAO0B,OAAO,GAAI3B,EAAlBC,OAAA,IAAAA,CAAA,GACKQ,EAAgBF,KAGzBG,EAAiB,MAgEL,2BACA,uBACA,oBAAII,MAAO,CAAEc,OAAQ,UACrB,wBAAQhB,QAAS,kBAAMD,EAAc,KAArC,iCAKJ,sBAAKtB,GAAG,8BAAR,UACI,2DACA,8BACKY,OAAO4B,QAAQ7B,GAAYsB,KACxB,mCAAEQ,EAAF,KAAaC,EAAb,YACI,8BACKD,EADL,KACkBC,EAAWC,KAAK,QAD1BF,WAQxB,qBAAKzC,GAAG,6BAAR,SACI,wBAAQuB,QAnFN,WACdb,EAAmBC,GACnBM,GAAuB,IAiFX,2B,gFC3Eb,SAAS2B,EAAQC,GAQpB,IANA,IAAML,EAAUK,EACXZ,KAAI,SAACa,EAAGC,GACL,MAAO,CAAEA,QAAOD,QAEnBE,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEH,EAAII,EAAEJ,KAEnBK,EAAIX,EAAQH,OAAS,EAAGc,GAAK,EAAGA,IACrCX,EAAQW,GAAGC,KAAOC,KAAKC,IACnB,EACAD,KAAKC,IACAd,EAAQH,OAASG,EAAQW,GAAGL,GAAMK,EAAI,GACvCA,EAAIX,EAAQH,OAAS,EAAIG,EAAQW,EAAI,GAAGC,KAAO,IAK3D,OAAOZ,EAAQQ,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEF,MAAQG,EAAEH,SAAOd,KAAI,SAACsB,GAAD,OAAWA,EAAMH,Q,+BCvCnE,SAASI,EAAcrE,EAAMW,GAChC,OAAO,IAAI2D,IAAU,CACjBC,QAAQ,2BAEDC,EAAaC,eAAeC,QAC3B,SAACC,EAAKC,GAAN,OACInD,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACKmD,EAAS5E,EAAK6E,UAAUD,OAEjC,KAGDjE,EAAQ+D,QAAO,SAACC,EAAK1B,GAGpB,IAAM6B,EAAS9E,EACV6E,UADU,wBACiB5B,IAC3B8B,OAAM,SAAC/B,GAAD,OAAYgC,OAAOC,MAAMjC,MAC/BkC,OACCC,EAAOL,EAAOM,UACdC,EAAQP,EAAOQ,MAcrB,OAbAX,EAAI,iBAAD,OAAkB1B,IAAYjD,EAC5B6E,UAD4B,wBACD5B,IAC3BsC,QAGG,SAACvC,GAAD,OACIgC,OAAOC,MAAMjC,GACPwC,IAAOC,QACHN,EAAO,EAAIE,EACXF,EAAO,EAAIE,EAFfG,GAIAxC,KAEX2B,IACR,KAEPf,MAAO5D,EAAK0F,aACbR,OAaP,SAASS,EAAwB3F,EAAMW,GAA0B,IAAjB4C,EAAgB,uDAAH,EAGnDqC,EAAY,IAAIC,IAChBC,EAAO,SAACC,EAAIC,GAEd,GAAIJ,EAAUK,IAAIC,YAAMH,EAAIC,IAAM,OAAOJ,EAAUO,IAAID,YAAMH,EAAIC,IAGjE,IAAMI,EAAOpG,EAAK6E,UAAL,wBAAgCkB,IAAMM,UAC7CC,EAAOtG,EAAK6E,UAAL,wBAAgCmB,IAAMK,UAE7CE,EAAS,YAAI5D,MAAMyD,EAAKlD,QAAQxB,QAAQoB,KAC1C,SAACkB,GAAD,OAAQiB,MAAMmB,EAAKpC,MAAQiB,MAAMqB,EAAKtC,OAItCwC,EAAIC,IAAMC,UAGVN,EAAKO,QAAO,SAACC,EAAG5C,GAAJ,OAAUuC,EAAOvC,MAC7BsC,EAAKK,QAAO,SAACC,EAAG5C,GAAJ,OAAUuC,EAAOvC,OAOjC,OAJAwC,EAAItC,KAAK2C,IAAI5B,MAAMuB,GAAK,EAAIA,EAjCR,IAoCpBZ,EAAUkB,IAAIZ,YAAMH,EAAIC,GAAKQ,GACtBA,GAILO,EAAa,IAAIlB,IACjBmB,EAAQ,SAACjB,EAAIC,GAGf,GAAIe,EAAWd,IAAIC,YAAMH,EAAIC,IAAM,OAAOe,EAAWZ,IAAID,YAAMH,EAAIC,IAGnE,IAAMI,EAAOpG,EAAK6E,UAAL,wBAAgCkB,IAAMM,UAC7CC,EAAOtG,EAAK6E,UAAL,wBAAgCmB,IAAMK,UAE7CY,EAASR,IAEX,YAAI9D,MAAMyD,EAAKlD,QAAQxB,QAGlBiF,QAAO,SAAC3C,GAAD,OAAQiB,MAAMmB,EAAKpC,MAAQiB,MAAMqB,EAAKtC,OAE7ClB,KAAI,SAACkB,GAAD,OAAQoC,EAAKpC,GAAKsC,EAAKtC,MAAQoC,EAAKpC,GAAKsC,EAAKtC,IAAM,OAG3DkD,EAAM,CACR/B,KAAM8B,EAAO9B,OACbG,IAAK2B,EAAO5B,SAKhB,OADA0B,EAAWD,IAAIZ,YAAMH,EAAIC,GAAKkB,GACvBA,GAKLC,EAAqBxG,EAAQkD,MAC/B,SAACC,EAAGC,GAAJ,OACI/D,EACK6E,UADL,wBACgCf,IAC3ByB,QAAO,SAAC6B,GAAD,OAAUnC,MAAMmC,GAAO,EAAI,KAClCC,MACLrH,EACK6E,UADL,wBACgCd,IAC3BwB,QAAO,SAAC6B,GAAD,OAAUnC,MAAMmC,GAAO,EAAI,KAClCC,SAGPC,EAAkBtH,EAEnBuF,QAAO,SAACgC,GAEL,IAUIC,EALJ,GALkB/F,OAAOgG,OAAOF,GAC3BzE,KAAI,SAACsE,GAAD,OAAUnC,MAAMmC,GAAO,EAAI,KAC/B1C,QAAO,SAACgD,EAAKN,GAAN,OAAcM,EAAMN,KAGhB7D,EAAY,OAAOgE,EAPtB,oBAaCJ,GAbD,IAab,2BAAkC,CAAC,IAA1BQ,EAAyB,QAC9B,IAAK1C,MAAMsC,EAAI,iBAAD,OAAkBI,KAAO,CACnCH,EAAYG,EACZ,QAhBK,8BAsBb,IAAMC,EAAWnB,IACb9F,EACKgG,QACG,SAAC1D,GAAD,OACIA,IAAWuE,GACXvC,MAAMsC,EAAI,iBAAD,OAAkBtE,QAElCH,KAAI,SAACG,GAAD,OAAY6C,EAAK7C,EAAQuE,OACpCrC,OAGF,OAAOxE,EAAQ+D,QAAO,SAACC,EAAK1B,GACxB,IAAMmE,EAAMG,EAAI,iBAAD,OAAkBtE,IACjC,GAAIgC,MAAMmC,GAAM,OAIuBJ,EAAM/D,EAAQuE,GAAnCK,EAJF,EAIJ1C,KAAkB2C,EAJd,EAISxC,IAEfyC,EAAOvC,IAAOwC,OAChBH,EACAC,GAAQ5D,KAAK+D,KAAK,GAAKL,GAFdpC,GAKbb,EAAI,iBAAD,OAAkB1B,IACjBsE,EAAI,iBAAD,OAAkBC,IAAetD,KAAKgE,IAAI,EAAIH,QAIrDpD,EAAI,iBAAD,OAAkB1B,IAAYmE,EAErC,OAAOzC,IACR,OAENO,OAGCiD,EAAiB9D,EAAcrE,EAAMW,GAASyH,OAChDzH,EAAQmC,KAAI,SAACG,GAAD,8BAA6BA,OAG7C,OACIqE,EAEKe,IAAIF,GAAgB,SAACG,EAAQC,GAK1B,OAHe9G,OAAOgG,OAAOa,GAAQE,OACjC,SAACpB,GAAD,OAAUnC,MAAMmC,MAEJkB,EAASC,KAE5BrD,OAcN,SAASuD,EAAezI,EAAMwB,GAA6B,IAAjB+B,EAAgB,uDAAH,EAEpDmF,EAAa,GAcnB,OAbAlH,EAAWmH,SAAQ,SAAChI,EAAS2C,EAAWsF,GAEpC,IAF0C,EAEpCC,EAASlD,EAEX3F,EAAKoI,OAAOzH,EAAQmC,KAAI,SAACG,GAAD,8BAA6BA,OACrDtC,EACA4C,GANsC,cASrBsF,EAAOC,cATc,IAS1C,gCAAWlE,EAAX,QACI8D,EAAW9D,EAAO9D,MAAQ8D,EAAOE,QAVK,kCAavC,IAAIR,IAAU,CACjBC,QAAQ,2BAEDC,EAAaC,eAAeC,QAC3B,SAACC,EAAKC,GAAN,OACInD,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACKmD,EAAS5E,EAAK6E,UAAUD,OAEjC,KAGD8D,GAEP9E,MAAO5D,EAAK0F,aACbR,O,IC7PDV,E,WAMF,WAAYxE,EAAMW,GAAU,oBACxBoI,KAAK/I,KAAOA,EACZ+I,KAAKC,QAAUhJ,EACf+I,KAAKpI,QAAUA,EAGfoI,KAAKE,UAAY,IAAIpD,IAGrBkD,KAAKxF,WAAa,IAAIsC,IAGtBkD,KAAKG,YAAc,IAAIrD,IAEvBkD,KAAKI,mBAAqBJ,KAAKI,mBAAmBC,KAAKL,MACvDA,KAAKM,aAAeN,KAAKM,aAAaD,KAAKL,MAC3CA,KAAKO,aAAeP,KAAKO,aAAaF,KAAKL,MAC3CA,KAAKQ,cAAgBR,KAAKQ,cAAcH,KAAKL,M,4DAUjCS,GACRT,KAAKE,UAAUhD,IAAIuD,KAAMT,KAAK/I,KAAO+I,KAAKE,UAAU9C,IAAIqD,M,2CAgB5DC,QAAQC,IAAI,yBACZX,KAAK/I,KAAO+I,KAAK/I,KAEZ+E,OAAM,SAACwC,GAAD,OAAUA,EAAI,2BAA6BA,EAAG,WAEpDa,OAJO,sBAKD5D,EAAaC,gBALZ,YAMDsE,KAAKpI,QAAQmC,KAAI,SAACG,GAAD,8BAA6BA,SAEpDiC,OAEL6D,KAAKE,UAAUnC,IACXtC,EAAamF,cAAcC,oBAC3Bb,KAAK/I,Q,qCAOG,IAAD,OACXyJ,QAAQC,IAAI,oBACZX,KAAK/I,KAAO,IAAIsE,IAAU,CACtBC,QAAQ,2BAEDC,EAAaC,eAAeC,QAC3B,SAACC,EAAKC,GAAN,OACInD,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACKmD,EAAS,EAAK5E,KAAK6E,UAAUD,OAEtC,KAGDmE,KAAKpI,QAAQ+D,QACZ,SAACC,EAAK1B,GAAN,OACIxB,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,2BACsBwB,GAAW,EAAKjD,KAC7B6E,UADwB,wBACG5B,IAC3BsC,QAAO,SAACvC,GAAD,OAGJA,EAAQ,EAAIkB,KAAK2F,KAAK7G,GAAS8G,WAG/C,KAGRlG,MAAOmF,KAAK/I,KAAK0F,aAClBR,S,qCAOS,IAAD,OACXuE,QAAQC,IAAI,oBACZX,KAAK/I,KAAO+I,KAAK/I,KAEZ+E,OACG,SAACwC,GAAD,OACK,EAAK5G,QAAQ6H,OAAM,SAACvF,GAAD,OAChBgC,MAAMsC,EAAI,iBAAD,OAAkBtE,WAGtCiC,OAEL6D,KAAKE,UAAUnC,IAAItC,EAAamF,cAAcI,cAAehB,KAAK/I,Q,uCAOrDgK,GAAY,IAAD,OAGxB,GAFAP,QAAQC,IAAI,uBAEPM,EAAL,CAUA,IAAMC,EAAU,IAAIpE,IACpBkD,KAAKpI,QAAQmC,KAAI,SAACG,GAAD,OACbgH,EAAQnD,IACJ7D,EACA,EAAKjD,KACA6E,UADL,wBACgC5B,IAC3B8B,OAAM,SAAC/B,GAAD,OAAYgC,OAAOC,MAAMjC,MAC/BkH,aAGb,IAAMC,EAAYjG,KAAK2C,IAAIuD,MAAM,KAAMzH,MAAMC,KAAKqH,EAAQxC,WAE1DsB,KAAK/I,KAAO,IAAIsE,IAAU,CACtBC,QAAQ,2BAEDC,EAAaC,eAAeC,QAC3B,SAACC,EAAKC,GAAN,OACInD,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACKmD,EAAS,EAAK5E,KAAK6E,UAAUD,OAEtC,KAGDmE,KAAKpI,QAAQ+D,QACZ,SAACC,EAAK1B,GAAN,OACIxB,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,2BACsBwB,GAAW,EAAKjD,KAC7B6E,UADwB,wBACG5B,IAC3BsC,QAIG,SAACvC,GAAD,OACKA,EAAQmH,EACTF,EAAQ9D,IAAIlD,UAGhC,KAGRW,MAAOmF,KAAK/I,KAAK0F,aAClBR,OAEH6D,KAAKE,UAAUnC,IACXtC,EAAamF,cAAcU,qBAC3BtB,KAAK/I,WAtDL+I,KAAKE,UAAUnC,IACXtC,EAAamF,cAAcU,qBAC3BtB,KAAK/I,Q,oCA8DHuD,GACVwF,KAAKxF,WAAW+G,QAChB,cAAmC7I,OAAO4B,QAAQE,GAAlD,0CAAYD,EAAZ,KAAuB3C,EAAvB,KACIoI,KAAKxF,WAAWuD,IAAIxD,EAAW3C,M,0CASnB4J,GAGhB,OAFAd,QAAQC,IAAI,2BAEJa,GACJ,KAAK/F,EAAagG,mBAAmBC,UACjC1B,KAAK/I,KAAO0K,EAAyB3B,KAAK/I,KAAM+I,KAAKpI,SACrD,MACJ,KAAK6D,EAAagG,mBAAmBG,UACjC5B,KAAK/I,KAAO0K,EACR3B,KAAK/I,KACL+I,KAAKxF,YAET,MACJ,KAAKiB,EAAagG,mBAAmBI,UACjC7B,KAAK/I,KAAO0K,EACR3B,KAAK/I,KACL+I,KAAKxF,WACL,GAIZwF,KAAKE,UAAUnC,IACXtC,EAAamF,cAAckB,sBAC3B9B,KAAK/I,Q,sCAUGkJ,GAAc,IAAD,OACzBO,QAAQC,IAAI,sBAEZ,IAHyB,2CAGboB,EAHa,KAGD9H,EAHC,KAIhB,EAAKkG,YAAYjD,IAAI6E,IACtB,EAAK5B,YAAYpC,IAAIgE,EAAY,IAAIjF,KALpB,oBAOI7C,GAPJ,yBAOV+H,EAPU,QAQXC,EAAiB1G,IAAU+D,IAI7B,CAACyC,EAAYC,GAAYjI,KAAI,SAACQ,GAAD,OACzBgB,IAAU+D,IACN,EAAK9E,WACA4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACD,EAAKjD,KAAK6E,UAAV,wBACqB5B,QAK7B,SAACwE,GAAD,OAAYA,EAAOpB,iBAK3B,YAAmB,IAAD,qBAAhB4E,EAAgB,KAAVC,EAAU,KAGRC,EAAQ1E,IAAMwE,GAAM9F,OACpBiG,EAAQ3E,IAAMyE,GAAM/F,OAGpBkG,EF9QvB,SAAejF,EAAME,GACxB,IAAMgF,EAAK7E,IAAML,GAAMjB,OACjBoG,EAAK9E,IAAMH,GAAMnB,OACjBY,EAAKU,IAAML,GAAMf,OAAM,GACvBW,EAAKS,IAAMH,GAAMjB,OAAM,GACvBmG,EAAKtH,KAAK+D,KACZ/D,KAAKuH,IAAI1F,EAAI,GAAKK,EAAKlD,OAASgB,KAAKuH,IAAIzF,EAAI,GAAKM,EAAKpD,QAErDwI,EAAKxH,KAAKyH,MACZzH,KAAKuH,IACDvH,KAAKuH,IAAI1F,EAAI,GAAKK,EAAKlD,OAASgB,KAAKuH,IAAIzF,EAAI,GAAKM,EAAKpD,OACvD,IAECgB,KAAKuH,IAAI1F,EAAI,IAAM7B,KAAKuH,IAAIrF,EAAKlD,OAAQ,IAAMkD,EAAKlD,OAAS,IAC1DgB,KAAKuH,IAAIzF,EAAI,IACR9B,KAAKuH,IAAInF,EAAKpD,OAAQ,IAAMoD,EAAKpD,OAAS,MAErD0I,GAAKL,EAAKD,GAAME,EAEtB,MAAO,CAAEI,IAAGjI,EADF,EAAI8C,IAAMoF,SAASC,KAAK5H,KAAKgE,IAAI0D,GAAIF,GAChCA,ME2PoBK,CAAMd,EAAMC,GAAMvH,EACjC,OAAO,EAAP,gCACamH,GAAeK,GAD5B,6BAEaJ,GAAeK,GAF5B,cAGI,SAAUA,EAAQD,GAHtB,cAII,UAAWE,GAJf,KASHW,WACGxH,EAAaC,eAAeC,QACxB,SAACC,EAAKC,GAAN,OACInD,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACKmD,EAAS,EAAK5E,KAAK6E,UAAUD,OAEtC,KAGPqH,UAAU,EAAKjM,KAAK0F,YACpBR,OACA8G,WAAW,CACR,mBAAoB,SAACN,GAAD,OAChB,IAAIQ,IAAO,CACPtI,MAAO8H,EAAGhG,WACV+B,OAAQhE,EACJiI,EAAG7G,UAAU,WAAWwB,gBAIvCnB,OAGL,EAAKgE,YACA/C,IAAI2E,GACJhE,IAAIiE,EAAYC,IA/DzB,2BAAiC,IAPZ,gCAGzB,MAAkCvJ,OAAO4B,QAAQ6F,GAAjD,eAAgE,Q,KAhPlE1E,EA0BKmF,cAAgB,CACnBC,oBAAqB,sBACrBG,cAAe,gBACfM,qBAAsB,uBACtBQ,sBAAuB,yBA9BzBrG,EAqCKC,eAAiB,CAAC,KAAM,YAAa,QArC1CD,EAuCKgG,mBAAqB,CACxBC,UAAW,YACXE,UAAW,YACXC,UAAW,aA+QJpG,QCtTfrD,IAAMC,cAAc,SA0FLnB,mBACX,SAACoB,GACG,MAAO,MAEX,SAACnB,GACG,MAAO,CACHiM,cAAe,SAACC,GACZlM,EL1DT,SAAkBkM,GACrB,OAAO,SAAClM,GAEJR,EAAO2M,SAASD,IKuDCC,CAASD,QAPnBnM,EAxFf,YAA6C,IAAlBkM,EAAiB,EAAjBA,cAAiB,EACcxK,IAAMC,UAAS,GAD7B,mBACjC0K,EADiC,KACZC,EADY,OAEV5K,IAAMC,SAAS,CACzCoI,WAAW,EACXO,OAAQ/F,EAAagG,mBAAmBC,YAJJ,mBAEjC2B,EAFiC,KAExBI,EAFwB,KAYxC,OACI,gCACI,wCACA,wBAAQpK,QAAS,kBAAMmK,GAAuB,IAA9C,mCAIA,6BACI,uIAMJ,eAAC,IAAD,CACIlK,OAAQiK,EACRzL,GAAG,yBACHyB,MAAO,CACHC,QAAS,CACLC,OAAQ,MALpB,UASI,oBAAI3B,GAAG,8BAAP,gCAEA,sBAAKA,GAAG,8BAAR,UACI,gDACA,uBACId,KAAK,WACLc,GAAG,mBACH4L,QAASL,EAAQpC,UACjBtH,SAAU,SAAC1B,GAAD,OACNwL,EACI/K,OAAO0B,OAAO,GAAIiJ,EAAS,CACvBpC,UAAWhJ,EAAEC,OAAOwL,cAKpC,uBAAO7L,QAAQ,mBAAf,+BACA,4CACA,yBACI8B,SAAU,SAAC1B,GAAD,OACNwL,EACI/K,OAAO0B,OAAO,GAAIiJ,EAAS,CACvB7B,OAAQvJ,EAAE0L,cAAc1J,UAJxC,UASI,wBACIA,MAAOwB,EAAagG,mBAAmBC,UAD3C,wBAKA,wBACIzH,MAAOwB,EAAagG,mBAAmBG,UAD3C,wBAKA,wBACI3H,MAAOwB,EAAagG,mBAAmBI,UAD3C,8BAQR,qBAAK/J,GAAG,6BAAR,SACI,wBAAQuB,QA1EN,WACd+J,EAAcC,GACdG,GAAuB,IAwEX,2B,QCpFpBpL,IAAMC,cAAc,SA+FLnB,mBACX,SAACoB,GACG,MAAO,CACHG,WAAYH,EAAMC,MAAME,eAGhC,SAACtB,GACG,MAAO,CACHyM,mBAAoB,SAACzD,GACjB,IAAM0D,EAAiBjK,MAAMC,KAAKsG,EAAYxH,QAAQgD,QAClD,SAACC,EAAKrB,GAAN,OACI7B,OAAO0B,OAAOwB,EAAdlD,OAAA,IAAAA,CAAA,GACK6B,EAAYX,MAAMC,KAAKsG,EAAY/C,IAAI7C,QAEhD,IAEJpD,ENhET,SAA6BgJ,GAChC,OAAO,SAAChJ,GAEJR,EAAOmN,oBAAoB3D,GAAa3I,MAAK,WACzCL,EAASJ,EAAaD,EAA+BqJ,QM4DxC2D,CAAoBD,QAhB9B3M,EA7Ff,YAAuE,IAAnCuB,EAAkC,EAAlCA,WAAYmL,EAAsB,EAAtBA,mBAAsB,EACZhL,IAAMC,UAAS,GADH,mBAC3DkL,EAD2D,KACtCC,EADsC,KAG5D7D,EAAc,IAAIrD,IAqBxB,OACI,gCACI,wCACA,wBAAQzD,QAAS,kBAAM2K,GAAuB,IAA9C,gCAIA,+BACI,qGAIA,sFACA,qGAMJ,eAAC,IAAD,CACI1K,OAAQyK,EACRjM,GAAG,yBACHyB,MAAO,CACHC,QAAS,CACLC,OAAQ,MALpB,UASI,oBAAI3B,GAAG,8BAAP,gCAEA,gCACI,kCACI,+BACI,uBACCW,EAAWsB,KAAI,SAACQ,GAAD,OACZ,6BAA4BA,GAA5B,UAAYA,EAAZ,aAGP9B,EAAWsB,KAAI,SAACgI,GAAD,OACZ,+BACI,6BAA6BA,GAA7B,UAAYA,EAAZ,OACCtJ,EAAWsB,KAAI,SAACiI,GAAD,OACZ,6BACI,uBACIhL,KAAK,WACL2C,SAAU,SAAC1B,GAAD,OAhEvB,SAAC8J,EAAYC,EAAYiC,GAC5CA,GACK9D,EAAYjD,IAAI6E,IACjB5B,EAAYpC,IAAIgE,EAAY,IAAImC,KACpC/D,EAAY/C,IAAI2E,GAAYoC,IAAInC,IAG5B7B,EAAYjD,IAAI6E,IAChB5B,EAAY/C,IAAI2E,GAAY7E,IAAI8E,IAEhC7B,EAAY/C,IAAI2E,GAAYqC,OAAOpC,GAuDHqC,CACItC,EACAC,EACA/J,EAAEC,OAAOwL,UAGjBY,SAAUvC,IAAeC,KAVjC,UAAYD,EAAZ,YAA0BC,SAHlC,UAAYD,EAAZ,iBAsBZ,qBAAKjK,GAAG,8BAAR,SACI,wBAAQuB,QAnEN,WACduK,EAAmBzD,GACnB6D,GAAuB,IAiEX,2BC9ELO,MAXf,YAAiC,IAAPzM,EAAM,EAANA,GACtB,OACI,sBAAKA,GAAIA,EAAI0M,UAAU,kBAAvB,UACI,cAAC,EAAD,IACA,cAAC,EAAD,IACA,cAAC,EAAD,IACA,cAAC,EAAD,Q,4CCTCC,EAAU,CACnBC,WAAY,aACZC,2BAA4B,6BAC5BC,4BAA6B,8BAC7BC,QAAS,UACTC,kBAAmB,qBAGhB,SAAeC,EAAtB,kC,4CAAO,WAAoC1B,GAApC,iBAAAtI,EAAA,sDACK/D,EAASqM,EAATrM,KAEJgO,EAAM,CAAE/N,KAAM,GAAIgO,OAAQ,IAH3B,KAIKjO,EAJL,cAKMyN,EAAQC,WALd,SAQMD,EAAQE,2BARd,SAWMF,EAAQG,4BAXd,UAcMH,EAAQI,QAdd,UAiBMJ,EAAQK,kBAjBd,mCAMiBI,EAAc7B,GAN/B,cAMK2B,EANL,oDASiBG,GAA4B9B,GAT7C,eASK2B,EATL,qDAYiBI,GAA6B/B,GAZ9C,eAYK2B,EAZL,qDAeiBK,GAAgBhC,GAfjC,eAeK2B,EAfL,qDAkBiBM,GAAoBjC,GAlBrC,eAkBK2B,EAlBL,2CAqBHA,EAAIC,OAAOM,UAAW,EArBnB,kBAuBIP,GAvBJ,6C,+BA0BQE,E,8EAAf,qCAAAnK,EAAA,yDAA+BnD,EAA/B,EAA+BA,QAASa,EAAxC,EAAwCA,WAC9B+M,EAAkB,SAACC,GACrB,OAAO/M,OAAO0B,OAAOqL,EAAO,CACxBzO,KAAM,SACN0O,MAAO,EACPC,QAAQ,KAIZX,EAAM,CAAE/N,KAAM,GAAIgO,OAAQ,SACfW,GAAXhO,QAAsCgO,GAAdnN,EAVhC,iCAYwBoN,QAAQC,IAChBlO,EAAQmC,KAAI,SAACG,GAAD,OACRvD,EACKoP,QADL,wBAEyB7L,GACjBuB,EAAamF,cAAcI,eAE9BxJ,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZQ,EAAG/O,EACHgP,GAAI/L,EACJgM,KAAM,oBAvBtC,wBA4BoB,GAjBZlB,EAXR,CAYY/N,KAZZ,KA4BYgO,OA5BZ,sCA8B0BW,GAAXhO,QAAsCgO,GAAdnN,EA9BvC,kCA+BiC9B,EAAOwP,gBA/BxC,eA+Bc3L,EA/Bd,iBAiCwBqL,QAAQC,IAChBrN,EAAWsB,KAAI,SAACQ,GAAD,OACXsL,QAAQC,IACJtL,EACK4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACDvD,EAAOoP,QAAP,wBACqB7L,GACjBuB,EAAamF,cACRU,0BAIhB9J,MAAK,SAAC4O,GAAD,OAAWA,EAAMC,UACtB7O,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZQ,EAAG/O,EACHgP,GAAI1L,EACJ2L,KAAM,oBAnDtC,yBAwDoB,GAxBZlB,EAhCR,CAiCY/N,KAjCZ,KAwDYgO,OAxDZ,qBA4DIvM,OAAO0B,OAAO4K,EAAIC,OAAQ,CACtBqB,MAAO,mBACPC,YAAY,EACZC,MAAO,CACHF,MAAO,kBAEXG,MAAO,CACHC,YAAY,KAnExB,kBAsEW1B,GAtEX,6C,+BAyEeG,G,iFAAf,qCAAApK,EAAA,yDAA6CnD,EAA7C,EAA6CA,QAASa,EAAtD,EAAsDA,WAC5C+M,EAAkB,SAACC,GACrB,OAAO/M,OAAO0B,OAAOqL,EAAO,CACxBzO,KAAM,SACN0O,MAAO,EACPC,QAAQ,KAIZX,EAAM,CAAE/N,KAAM,GAAIgO,OAAQ,SACfW,GAAXhO,QAAsCgO,GAAdnN,EAVhC,iCAYwBoN,QAAQC,IAAR,sBACLlO,EAAQmC,KAAI,SAACG,GAAD,OACXvD,EACKoP,QADL,wBAEyB7L,GACjBuB,EAAamF,cAAcU,sBAE9B9J,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZzN,KAAM,MACNiO,EAAG/O,EACHgP,GAAI/L,EACJyM,YAAa,MACbT,KAAM,oBAbd,YAiBLtO,EAAQmC,KAAI,SAACG,GAAD,OACXvD,EACKoP,QADL,wBAEyB7L,GACjBuB,EAAamF,cAAckB,uBAE9BtK,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZzN,KAAM,OACNiO,EAAG/O,EACHgP,GAAI/L,EACJyM,YAAa,OACbT,KAAM,sBAzCtC,wBA8CoB,GAnCZlB,EAXR,CAYY/N,KAZZ,KA8CYgO,OA9CZ,sCAgD0BW,GAAXhO,QAAsCgO,GAAdnN,EAhDvC,kCAiDiC9B,EAAOwP,gBAjDxC,eAiDc3L,EAjDd,iBAmDwBqL,QAAQC,IAAR,sBACLrN,EAAWsB,KAAI,SAACQ,GAAD,OACdsL,QAAQC,IACJtL,EACK4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACDvD,EAAOoP,QAAP,wBACqB7L,GACjBuB,EAAamF,cACRU,0BAIhB9J,MAAK,SAAC4O,GAAD,OAAWA,EAAMC,UACtB7O,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZzN,KAAM,MACNiO,EAAG/O,EACHgP,GAAI1L,EACJoM,YAAa,MACbT,KAAM,oBApBd,YAwBLzN,EAAWsB,KAAI,SAACQ,GAAD,OACdsL,QAAQC,IACJtL,EACK4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACDvD,EAAOoP,QAAP,wBACqB7L,GACjBuB,EAAamF,cACRkB,2BAIhBtK,MAAK,SAAC4O,GAAD,OAAWA,EAAMC,UACtB7O,MAAK,SAACP,GAAD,OACFuO,EAAgB,CACZzN,KAAM,OACNiO,EAAG/O,EACHgP,GAAI1L,EACJoM,YAAa,OACbT,KAAM,sBA9FtC,yBAmGoB,GAjDZlB,EAlDR,CAmDY/N,KAnDZ,KAmGYgO,OAnGZ,qBAuGIvM,OAAO0B,OAAO4K,EAAIC,OAAQ,CACtBqB,MAAO,4CACPE,MAAO,CACHF,MAAO,kBAEXG,MAAO,CACHC,YAAY,KA7GxB,kBAgHW1B,GAhHX,6C,+BAmHeI,G,iFAAf,qCAAArK,EAAA,yDAA8CnD,EAA9C,EAA8CA,QAASa,EAAvD,EAAuDA,WAC7CmO,EAAmB,SAACnB,GACtB,OAAO/M,OAAO0B,OAAOqL,EAAO,CACxBzO,KAAM,SAIVgO,EAAM,CAAE/N,KAAM,GAAIgO,OAAQ,SACfW,GAAXhO,QAAsCgO,GAAdnN,EARhC,iCAUwBoN,QAAQC,IAAR,sBACLlO,EAAQmC,KAAI,SAACG,GAAD,OACXvD,EACKoP,QADL,wBAEyB7L,GACjBuB,EAAamF,cAAcU,sBAE9B9J,MAAK,SAACP,GAAD,OACF2P,EAAiB,CACb7O,KAAM,MACN8O,EAAG5P,EACH6P,GAAI5M,EACJyM,YAAa,eAZrB,YAgBL/O,EAAQmC,KAAI,SAACG,GAAD,OACXvD,EACKoP,QADL,wBAEyB7L,GACjBuB,EAAamF,cAAckB,uBAE9BtK,MAAK,SAACP,GAAD,OACF2P,EAAiB,CACb7O,KAAM,OACN8O,EAAG5P,EACH6P,GAAI5M,EACJyM,YAAa,kBArC7C,wBA0CoB,GAjCZ3B,EATR,CAUY/N,KAVZ,KA0CYgO,OA1CZ,sCA4C0BW,GAAXhO,QAAsCgO,GAAdnN,EA5CvC,kCA6CiC9B,EAAOwP,gBA7CxC,eA6Cc3L,EA7Cd,iBA+CwBqL,QAAQC,IAAR,sBACLrN,EAAWsB,KAAI,SAACQ,GAAD,OACdsL,QAAQC,IACJtL,EACK4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACDvD,EAAOoP,QAAP,wBACqB7L,GACjBuB,EAAamF,cACRU,0BAIhB9J,MAAK,SAAC4O,GAAD,OAAWA,EAAMC,UACtB7O,MAAK,SAACP,GAAD,OACF2P,EAAiB,CACb7O,KAAM,MACN8O,EAAG5P,EACH6P,GAAIvM,EACJoM,YAAa,eAnBrB,YAuBLlO,EAAWsB,KAAI,SAACQ,GAAD,OACdsL,QAAQC,IACJtL,EACK4C,IAAI7C,GACJR,KAAI,SAACG,GAAD,OACDvD,EAAOoP,QAAP,wBACqB7L,GACjBuB,EAAamF,cACRkB,2BAIhBtK,MAAK,SAAC4O,GAAD,OAAWA,EAAMC,UACtB7O,MAAK,SAACP,GAAD,OACF2P,EAAiB,CACb7O,KAAM,OACN8O,EAAG5P,EACH6P,GAAIvM,EACJoM,YAAa,kBAxF7C,yBA6FoB,GA/CZ3B,EA9CR,CA+CY/N,KA/CZ,KA6FYgO,OA7FZ,qBAiGIvM,OAAO0B,OAAO4K,EAAIC,OAAQ,CACtBqB,MAAO,4CACPE,MAAO,CACHE,YAAY,GAEhBD,MAAO,CACHH,MAAO,kBAEXS,QAAS,QACTC,QAAS,EACTC,YAAa,IA3GrB,kBA6GWjC,GA7GX,6C,+BAgHeK,G,iFAAf,iCAAAtK,EAAA,yDAAiCoF,EAAjC,EAAiCA,YAAa+G,EAA9C,EAA8CA,eACrC/G,EADT,yCAC6B,CAAElJ,KAAM,GAAIgO,OAAQ,KADjD,cAEUkC,EAAmB,IAAIjD,KACxBgD,GAAkB,IAAInN,KAAI,SAACqN,GAAD,OAAOA,EAAEC,kBAH5C,SAOkBxB,QAAQC,IAAI,CACdnP,EAAO2Q,kBAAkBnH,EAAa,UACtCxJ,EAAO2Q,kBAAkBnH,EAAa,oBACtCxJ,EAAO2Q,kBAAkBnH,EAAa,UACvC3I,MAAK,YAA8B,IAAD,mBAA3B+P,EAA2B,KAApB5M,EAAoB,KAAX6M,EAAW,KACjC,MAAO,CACHxQ,KAAM,YACNyQ,KAAM,UACNzB,EAAGuB,EACHV,EAAGlM,EAAQZ,KAAI,SAACa,GAAD,OAAQ,EAAIO,KAAKuM,MAAM9M,MACtC+M,UAAWH,EACXI,OAAQ,CACJC,MAAOL,EAAMzN,KAAI,SAACqN,GAAD,OACbD,EAAiBjK,IAAIkK,EAAEC,eAAiB,EAAI,UApBxE,2CA0BgB,CACJf,MAAM,GAAD,OAAKnG,EAAY,GAAjB,gBAA2BA,EAAY,IAC5CqG,MAAO,CACHF,MAAM,SAAD,OAAWnG,EAAY,GAAvB,cAA+BA,EAAY,GAA3C,MAETsG,MAAO,CACHH,MAAO,wBAhCvB,mBAMQrP,KANR,KA0BQgO,OA1BR,oD,+BAsCeK,G,iFAAf,6BAAAvK,EAAA,yDAAqCoF,EAArC,EAAqCA,YAArC,yCAC6B,CAAElJ,KAAM,GAAIgO,OAAQ,KADjD,uBAOyBtO,EAAO2Q,kBAAkBnH,EAAa,WAP/D,+BASuB,CACH2H,MAAO,EACPC,IAAK,EACLC,KAAM,MAZ1B,MAKgBhR,KAAM,YACNe,KAAM,UACNiO,EAPhB,KAQgBiC,QAAS,GACTC,MAThB,gBAkByBvR,EAAO2Q,kBACZnH,EACA,oBApBpB,gCAuBuB,CACH2H,MAAO,EACPC,IAAK,EACLC,KAAM,MA1B1B,MAgBgBhR,KAAM,YACNe,KAAM,mBACNiO,EAlBhB,KAsBgBiC,QAAS,GACTC,MAvBhB,4BA8BgB,CACJ5B,MAAM,GAAD,OAAKnG,EAAY,GAAjB,gBAA2BA,EAAY,GAAvC,aACLgI,QAAS,UACT3B,MAAO,CACHF,MAAO,KAEXG,MAAO,CACHH,MAAO,UArCvB,mBAGQrP,KAHR,KA8BQgO,OA9BR,oD,sBClVe/N,oBAAQ,SAACoB,GACpB,MAAO,CACH8P,cAAe9P,EAAM+P,KAAKD,iBAE/B,KAJYlR,EAhCf,YAAoD,IAAtBY,EAAqB,EAArBA,GAAIsQ,EAAiB,EAAjBA,cAAiB,EACvBxP,IAAMC,SAAS,CACnC5B,KAAM,GACNgO,OAAQ,CACJM,UAAU,KAJ6B,mBACxC+C,EADwC,KAClCC,EADkC,KAY/C,OAJA3P,IAAM4P,UAAN,sBAAgB,sBAAAzN,EAAA,0DACRqN,EADQ,4BACOG,EADP,SACqBxD,EAAqBqD,GAD1C,6EAEb,CAACA,IAEAE,EAEI,qBAAKxQ,GAAIA,EAAI0M,UAAU,iBAAvB,SACI,cAAC,IAAD,CACIA,UAAU,YACVvN,KAAMqR,EAAKrR,KACXgO,OAAQqD,EAAKrD,OACbwD,kBAAgB,EAChBlP,MAAO,CACHmM,MAAO,OACPgD,OAAQ,QAEZC,MAAM,uBAKf,gB,qBCAIzR,oBAAQ,SAACoB,GACpB,MAAO,CACH8P,cAAe9P,EAAM+P,KAAKD,iBAE/B,KAJYlR,EA5Bf,YAA6D,IAA/BY,EAA8B,EAA9BA,GAAasQ,GAAiB,EAA1BxQ,QAA0B,EAAjBwQ,eAAiB,EAChCxP,IAAMC,WAD0B,mBACjD5B,EADiD,KAC3C2R,EAD2C,KAUxD,OAPAhQ,IAAM4P,UAAN,sBAAgB,sBAAAzN,EAAA,0DACRqN,EAAcjI,YADN,4BAERyI,EAFQ,SAGEjS,EAAOkS,oBAAoBT,EAAcjI,aAH3C,6EAKb,CAACiI,EAAcjI,cAGd,qBAAKrI,GAAIA,EAAT,SACI,cAAC,KAAD,CACIwO,MACI8B,EAAcjI,YAAd,UACSiI,EAAcjI,YAAY,GADnC,gBAC6CiI,EAAcjI,YAAY,IACjE,wCAEVlJ,KAAMA,EACNuE,QAASvE,EAAOyB,OAAOC,KAAK1B,EAAK,IAAM,GACvCoM,QAAS,CACLyF,eAAgB,e,QCiGrB5R,oBAAQ,SAACoB,GACpB,MAAO,CACHV,QAASU,EAAMC,MAAMX,QACrBa,WAAYH,EAAMC,MAAME,WACxB0H,YAAa7H,EAAMC,MAAM4H,eAE9B,KANYjJ,EAtHf,YAMI,IAGImM,EARJzL,EAKD,EALCA,QACAa,EAID,EAJCA,WACA0H,EAGD,EAHCA,YACA4I,EAED,EAFCA,WACAC,EACD,EADCA,gBACD,EAC+CpQ,IAAMC,SAAS,WAD9D,mBACQoQ,EADR,KACyBC,EADzB,KAIC,OAAQH,GACJ,KAAKtE,EAAQC,WACb,KAAKD,EAAQE,2BACb,KAAKF,EAAQG,4BACT,IAAMuE,EAAqB,SAAClR,GACxBiR,EAAmBjR,EAAE0L,cAAc1J,OACnC+O,EAAgB,CACZpR,aAASgO,EACTnN,gBAAYmN,KAIpBvC,EACI,qCACI,gCACI,uBACIrM,KAAK,QACLc,GAAG,oBACHC,KAAK,aACLkC,MAAM,UACNyJ,QAA6B,YAApBuF,EACTtP,SAAUwP,IAEd,uBAAOtR,QAAQ,oBAAf,qBACA,uBACA,uBACIb,KAAK,QACLc,GAAG,uBACHC,KAAK,aACLkC,MAAM,aACNyJ,QAA6B,eAApBuF,EACTtP,SAAUwP,IAEd,uBAAOtR,QAAQ,uBAAf,2BAEJ,wBACI2M,UAAU,4BACV9K,UAAQ,EACRC,SAAU,SAAC1B,GACP+Q,EAAgB,eACXC,EAAkBrP,MAAMC,KACrB5B,EAAEC,OAAO4B,iBACXC,KAAI,SAACC,GAAD,OAASA,EAAIC,YAP/B,SAWK,CAAErC,UAASa,cAAawQ,GAAiBlP,KACtC,SAAChC,GAAD,OACI,wBAAQkC,MAAOlC,EAAf,SACKA,GADqBA,WAQ9C,MACJ,KAAK0M,EAAQI,QACb,KAAKJ,EAAQK,kBACTzB,EACI,qCACI,wBACImB,UAAU,sBACV9K,UAAQ,EACRC,SAAU,SAAC1B,GACP+Q,EAAgB,CACZ7I,YAAaiJ,KAAKC,MAAMpR,EAAEC,OAAO+B,UAL7C,SASKvB,OAAO4B,QAAQ6F,GAAe,IAC1BpG,KAAI,mCAAEgI,EAAF,iBACKhI,KAAI,SAACiI,GAAD,OACN,yBACI/H,MAAOmP,KAAKE,UAAU,CAClBvH,EACAC,IAHR,UAUKA,EAVL,QAUsBD,IALbqH,KAAKE,UAAU,CAChBvH,EACAC,WAOfqE,SAET,0BACI7B,UAAU,0BACV+E,YAAY,wEACZ5P,SAAU,SAAC1B,GAAD,OACN+Q,EAAgB,CACZ9B,eAAgBjP,EAAEC,OAAO+B,MACpBuP,MAAM,MACN5L,QAAO,SAACwJ,GAAD,MAAa,KAANA,aAS/C,OAAO,qBAAK5C,UAAU,mCAAf,SAAmDnB,O,QC3D/CnM,mBAAQ,MAAM,SAACC,GAC1B,MAAO,CACHsS,aAAc,SAACrB,GACXjR,EACIJ,EAAaD,EAAiCsR,KAGtDsB,gBAAiB,WACbvS,GZND,SAACA,GAEJR,EAAOgT,eAAenS,MAAK,SAACP,GAExB,IAAM2S,EAAO,IAAIC,KAAK,CAAC5S,GAAO,CAAED,KAAM,6BAChC8S,EAAOC,SAASC,cAAc,KACpCF,EAAKG,KAAOC,OAAOC,IAAIC,gBAAgBR,GACvCE,EAAKO,SAAW,eAChBP,EAAKQ,eYATC,gBAAiB,WACbpT,GZKD,SAACA,GACJqT,IAAOC,cAAc,mBAAoB,CACrCC,OAAQ,MACRhF,MAAO,KACPgD,OAAQ,KACRiC,SAAU,kBYrBPzT,EApDf,YAAgF,IAAvDY,EAAsD,EAAtDA,GAAI2R,EAAkD,EAAlDA,aAAcC,EAAoC,EAApCA,gBAAiBa,EAAmB,EAAnBA,gBAAmB,EACjC3R,IAAMC,SAAS,IADkB,mBACpEuP,EADoE,KACrDwC,EADqD,KAG3E,OACI,sBAAK9S,GAAIA,EAAI0M,UAAU,iBAAvB,UACI,qDACA,sBAAKA,UAAU,iBAAf,UAEI,wBACI7K,SAAU,SAAC1B,GACP2S,EACIlS,OAAO0B,OAAO,GAAIgO,EAAe,CAC7BpR,KAAMiB,EAAEC,OAAO+B,UAI3B4Q,aAAa,UARjB,UAWQ,wBAAQvG,UAAQ,EAACrK,MAAM,UAAvB,mCAAqC,YAX7C,mBAcWvB,OAAOC,KAAK8L,GAAS1K,KAAI,SAAC+Q,GAAD,OACxB,wBAAQ7Q,MAAO6Q,EAAf,SACKA,GADoBA,UAQrC,cAAC,GAAD,CACI/B,WAAYX,EAAcpR,KAC1BgS,gBAAiB,SAAC+B,GAAD,OACbH,EACIlS,OAAO0B,OAAO,GAAIgO,EAAe2C,OAM7C,wBAAQ1R,QAAS,kBAAMoQ,EAAarB,IAApC,uBAIA,wBAAQ/O,QAASqQ,EAAjB,2BACA,wBAAQrQ,QAASkR,EAAjB,sCCvCDS,OAXf,WACI,OACI,sBAAKlT,GAAG,gBAAR,UACI,cAAC,EAAD,CAAgBA,GAAG,oBACnB,cAAC,GAAD,CAAeA,GAAG,mBAClB,cAAC,GAAD,CAAoBA,GAAG,wBACvB,cAAC,GAAD,CAAoBA,GAAG,4B,oBCR7BmT,GAAe,CACjB1S,MAAO,CACHX,QAAS,GACTa,WAAY,IAEhB4P,KAAM,CACFD,cAAe,IAEnBlC,KAAM,GACNgF,KAAM,IAGV,SAASC,GAAa7S,EAAO8S,GACzB,OAAQA,EAAOpU,MACX,KAAKF,EACD,OAAO4B,OAAO0B,OAAO,GAAI9B,EAAO,CAC5BV,QAASwT,EAAOnU,OAExB,KAAKH,EACD,OAAO4B,OAAO0B,OAAO,GAAI9B,EAAO,CAC5BG,WAAY2S,EAAOnU,OAE3B,KAAKH,EACD,OAAO4B,OAAO0B,OAAO,GAAI9B,EAAO,CAC5B6H,YAAaiL,EAAOnU,OAGhC,OAAOqB,EAGX,SAAS+S,GAAY/S,EAAO8S,GACxB,OAAQA,EAAOpU,MACX,KAAKF,EACD,OAAO4B,OAAO0B,OAAO,GAAI9B,EAAO,CAC5B8P,cAAegD,EAAOnU,OAGlC,OAAOqB,EAkBX,IAAMgT,GACiB,qBAAXpB,QACJA,OAAOqB,sCACXC,KAEWC,iBApBf,WAAoD,IAA/BnT,EAA8B,uDAAtB2S,GAAcG,EAAQ,uCACzCM,EAAG,eAAQpT,GACjB,OAAQ8S,EAAOpU,MACX,KAAKF,EACL,KAAKA,EACL,KAAKA,EACD4U,EAAInT,MAAQ4S,GAAa7S,EAAMC,MAAO6S,GACtC,MACJ,KAAKtU,EACD4U,EAAIrD,KAAOgD,GAAY/S,EAAM+P,KAAM+C,GAG3C,OAAOM,IAUPJ,GAAiBK,aAAgBC,QCzDrCC,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,IAAD,CAAUC,MAAOA,GAAjB,SACI,cAAC,GAAD,QAGRjC,SAASkC,eAAe,U","file":"static/js/main.abcac3cb.chunk.js","sourcesContent":["/* eslint-disable import/no-webpack-loader-syntax */\nimport Worker from \"worker-loader!./worker.js\";\nimport { wrap } from \"comlink\";\n\n// instantiate worker for analysis\nconst worker = wrap(new Worker());\nexport default worker;\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/worker.a299461e.worker.js\");\n}\n","export const ACTIONS = {\n    SET_INPUT_SAMPLES: \"SET_INPUT_SAMPLES\",\n    SET_INPUT_CONDITIONS: \"SET_INPUT_CONDITIONS\",\n    SET_INPUT_COMPARISONS: \"SET_INPUT_COMPARISONS\",\n    SET_VIEW_FIGURE_OPTIONS: \"SET_VIEW_FIGURE_OPTIONS\",\n};\n\nexport function createAction(type, data) {\n    return {\n        type,\n        data,\n    };\n}\n","import { connect } from \"react-redux\";\nimport { onDataUpload } from \"../RunAnalysis\";\n\nfunction InputDataUpload({ onDataUpload }) {\n    return (\n        <div>\n            <label htmlFor=\"dataUpload\">\n                (1) Upload data to begin analysis:{\" \"}\n            </label>\n            <input\n                type=\"file\"\n                id=\"dataUpload\"\n                name=\"dataUpload\"\n                onInput={(e) => onDataUpload(e.target.files[0])}\n            />\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions per sample as\n                    violin plot or boxplot.\n                </li>\n            </ul>\n        </div>\n    );\n}\n\nexport default connect(null, (dispatch) => {\n    return {\n        onDataUpload: (file) => {\n            dispatch(onDataUpload(file));\n        },\n    };\n})(InputDataUpload);\n","import worker from \"./AnalysisWorker\";\nimport { transfer } from \"comlink\";\nimport { ACTIONS, createAction } from \"./store/actions\";\nimport Plotly from \"plotly.js\";\n\n/**\n * This file interfaces between UI and analysis. UI changes are handled on the\n * main thread (this file) while analysis is handled in a worker (see\n * worker.js); each function calls the equivalent function in the worker, via\n * comlink proxy, to handle the analysis aspect off of the main thread.\n */\n\nexport function onDataUpload(file) {\n    return (dispatch) => {\n        new Response(file)\n            // wrap file blob in response to read data as array buffer\n            .arrayBuffer()\n            // transfer array buffer to worker for processing and analysis\n            .then((ab) => {\n                return worker.onDataUpload(transfer(ab, [ab]));\n            })\n            // retrieve sample names\n            .then(() => {\n                return worker.getSamples();\n            })\n            // update UI with sample names\n            .then((samples) => {\n                dispatch(createAction(ACTIONS.SET_INPUT_SAMPLES, samples));\n            });\n    };\n}\n\nexport function onReplicatesSelect(conditions) {\n    return (dispatch) => {\n        // transfer conditions object to worker for processing\n        worker.onReplicatesSelect(conditions).then(() => {\n            // update UI with condition names\n            dispatch(\n                createAction(\n                    ACTIONS.SET_INPUT_CONDITIONS,\n                    Object.keys(conditions)\n                )\n            );\n        });\n    };\n}\n\nexport function onImpute(options) {\n    return (dispatch) => {\n        // transfer options to worker and do processing/imputation\n        worker.onImpute(options);\n    };\n}\n\nexport function onComparisonsSelect(comparisons) {\n    return (dispatch) => {\n        // transfer comparisons object to worker for processing\n        worker.onComparisonsSelect(comparisons).then(() => {\n            dispatch(createAction(ACTIONS.SET_INPUT_COMPARISONS, comparisons));\n        });\n    };\n}\n\nexport function downloadData() {\n    return (dispatch) => {\n        // get bytes to save as excel file from worker\n        worker.downloadData().then((data) => {\n            // make new blob and link pointing to blob, click to save file\n            const blob = new Blob([data], { type: \"application/vnd.ms-excel\" });\n            const link = document.createElement(\"a\");\n            link.href = window.URL.createObjectURL(blob);\n            link.download = \"results.xlsx\";\n            link.click();\n        });\n    };\n}\n\nexport function saveFigure() {\n    return (dispatch) => {\n        Plotly.downloadImage(\"mainpanel-figure\", {\n            format: \"png\",\n            width: 1024,\n            height: 1024,\n            filename: \"figure\",\n        });\n    };\n}\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputReplicateSelection.css\";\nimport { onReplicatesSelect } from \"../RunAnalysis\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputReplicateSelection({ samples, onReplicatesSelect }) {\n    const [replicatesModalOpen, setReplicatesModalOpen] = React.useState(false);\n    const [selectedReplicates, setSelectedReplicates] = React.useState([]);\n    const [conditionName, setConditionName] = React.useState(\"\");\n    const [conditions, setConditions] = React.useState({});\n\n    const onAddCondition = () => {\n        if (conditionName.length === 0) return;\n        setConditions(\n            Object.assign({}, conditions, {\n                [conditionName]: selectedReplicates,\n            })\n        );\n        setConditionName(\"\");\n    };\n\n    const onOKClick = () => {\n        onReplicatesSelect(conditions);\n        setReplicatesModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(2) </span>\n            <button onClick={() => setReplicatesModalOpen(true)}>\n                Select replicates\n            </button>\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions per condition\n                    as violin plot or boxplot.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={replicatesModalOpen}\n                id=\"input-replicate-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-replicate-modal-head\">Select replicates</h1>\n\n                <div id=\"input-replicate-modal-left\">\n                    <p>Samples present in data:</p>\n                    <select\n                        multiple\n                        onChange={(e) => {\n                            setSelectedReplicates(\n                                Array.from(e.target.selectedOptions).map(\n                                    (opt) => opt.value\n                                )\n                            );\n                        }}\n                    >\n                        {samples.map((sample) => (\n                            <option value={sample} key={sample}>\n                                {sample}\n                            </option>\n                        ))}\n                    </select>\n                </div>\n\n                <div>\n                    <p>New condition wtih selected samples as replicates:</p>\n                    <label htmlFor=\"conditionName\">Condition name: </label>\n                    <input\n                        type=\"text\"\n                        id=\"conditionName\"\n                        name=\"conditionName\"\n                        value={conditionName}\n                        onChange={(e) => setConditionName(e.target.value)}\n                    />\n                    <br />\n                    <button onClick={onAddCondition}>Add condition</button>\n                    <br />\n                    <hr style={{ margin: \"2rem\" }} />\n                    <button onClick={() => setConditions({})}>\n                        Reset conditions\n                    </button>\n                </div>\n\n                <div id=\"input-replicate-modal-right\">\n                    <p>Conditions and replicates:</p>\n                    <div>\n                        {Object.entries(conditions).map(\n                            ([condition, replicates]) => (\n                                <p key={condition}>\n                                    {condition}: {replicates.join(\", \")}\n                                </p>\n                            )\n                        )}\n                    </div>\n                </div>\n\n                <div id=\"input-replicate-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {\n            samples: state.input.samples,\n        };\n    },\n    (dispatch) => {\n        return {\n            onReplicatesSelect: (conditions) => {\n                dispatch(onReplicatesSelect(conditions));\n            },\n        };\n    }\n)(InputReplicateSelection);\n","import jstat from \"jstat\";\n\n/**\n * Calculates two-sample Welch's t-test (two tail).\n * @param {number[]} arr1 sample 1\n * @param {number[]} arr2 sample 2\n */\nexport function ttest(arr1, arr2) {\n    const m1 = jstat(arr1).mean();\n    const m2 = jstat(arr2).mean();\n    const s1 = jstat(arr1).stdev(true);\n    const s2 = jstat(arr2).stdev(true);\n    const se = Math.sqrt(\n        Math.pow(s1, 2) / arr1.length + Math.pow(s2, 2) / arr2.length\n    );\n    const df = Math.floor(\n        Math.pow(\n            Math.pow(s1, 2) / arr1.length + Math.pow(s2, 2) / arr2.length,\n            2\n        ) /\n            (Math.pow(s1, 4) / (Math.pow(arr1.length, 2) * (arr1.length - 1)) +\n                Math.pow(s2, 4) /\n                    (Math.pow(arr2.length, 2) * (arr2.length - 1)))\n    );\n    const t = (m2 - m1) / se;\n    const p = 2 * jstat.studentt.cdf(-Math.abs(t), df);\n    return { t, p, df };\n}\n\n/**\n * Adjust p values using Benjamini-Hochberg method (FDR)\n * @param {number[]} pvalues array containing p values\n */\nexport function pAdjust(pvalues) {\n    // enumerate indices for original order, then sort by p value\n    const entries = pvalues\n        .map((p, index) => {\n            return { index, p };\n        })\n        .sort((a, b) => a.p - b.p);\n    // calculate BH corrected p value\n    for (let i = entries.length - 1; i >= 0; i--) {\n        entries[i].padj = Math.min(\n            1,\n            Math.min(\n                (entries.length * entries[i].p) / (i + 1),\n                i < entries.length - 1 ? entries[i + 1].padj : 1\n            )\n        );\n    }\n    // use original order (sort by index) then return adjusted p values\n    return entries.sort((a, b) => a.index - b.index).map((entry) => entry.padj);\n}\n","import { DataFrame, Series } from \"data-forge\";\nimport random from \"random\";\nimport MSExperiment from \"./MSExperiment\";\nimport jstat from \"jstat\";\nimport { tuple } from \"immutable-tuple\";\n\n/**\n * Do imputation from uniform distribution between sample mean - 3 * std to\n * mean - 2 * std\n * @param {DataFrame} data DataFrame containing intensity data\n * @param {string[]} samples names of samples\n */\nexport function imputeUniform(data, samples) {\n    return new DataFrame({\n        columns: {\n            // copy common columns from current dataframe\n            ...MSExperiment.COMMON_COLUMNS.reduce(\n                (obj, column) =>\n                    Object.assign(obj, {\n                        [column]: data.getSeries(column),\n                    }),\n                {}\n            ),\n            // perform imputation on LFQ intensity columns\n            ...samples.reduce((obj, sample) => {\n                // compute mean and standard deviation of non-NaN log\n                // intensity values for the sample\n                const series = data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .where((value) => !Number.isNaN(value))\n                    .bake();\n                const mean = series.average();\n                const stdev = series.std();\n                obj[`LFQ intensity ${sample}`] = data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .select(\n                        // replace NaN's with random values drawn from\n                        // uniform distribution\n                        (value) =>\n                            Number.isNaN(value)\n                                ? random.uniform(\n                                      mean - 3 * stdev,\n                                      mean - 2 * stdev\n                                  )()\n                                : value\n                    );\n                return obj;\n            }, {}),\n        },\n        index: data.getIndex(),\n    }).bake();\n}\n\n// minimum correlation\nconst MINIMUM_CORRELATION = 0.1;\n\n/**\n * Do relative imputation in a single condition.\n * @param {DataFrame} data DataFrame containing the relevant sample columns\n * @param {string[]} samples names of samples in the same condition\n * @param {number} replicates threshold number of replicates; do not impute if\n * the protein is detected in fewer than `replicate` replicates\n */\nfunction imputeConditionRelative(data, samples, replicates = 2) {\n    // calculate Pearson correlation coefficient between non-NaN values of two\n    // samples\n    const corrCache = new Map();\n    const corr = (s1, s2) => {\n        // return calculated correlation if already in cache\n        if (corrCache.has(tuple(s1, s2))) return corrCache.get(tuple(s1, s2));\n\n        // get sample values as arrays\n        const arr1 = data.getSeries(`LFQ intensity ${s1}`).toArray();\n        const arr2 = data.getSeries(`LFQ intensity ${s2}`).toArray();\n        // mask proteins with NaN in either sample: true if non-NaN in both\n        const arrNaN = [...Array(arr1.length).keys()].map(\n            (i) => !isNaN(arr1[i]) && !isNaN(arr2[i])\n        );\n\n        // calculate Pearson correlation coefficient\n        let c = jstat.corrcoeff(\n            // filter both arrays to only use proteins that are not NaN in both\n            // samples\n            arr1.filter((v, i) => arrNaN[i]),\n            arr2.filter((v, i) => arrNaN[i])\n        );\n        // use a minimum value for correlation\n        c = Math.max(isNaN(c) ? 0 : c, MINIMUM_CORRELATION);\n\n        // put correlation in cache and return\n        corrCache.set(tuple(s1, s2), c);\n        return c;\n    };\n\n    // calculate distribution of deltas between two samples\n    const deltaCache = new Map();\n    const delta = (s1, s2) => {\n        // return calculated mean and standard deviation on delta if already in\n        // cache\n        if (deltaCache.has(tuple(s1, s2))) return deltaCache.get(tuple(s1, s2));\n\n        // get sample values as arrays\n        const arr1 = data.getSeries(`LFQ intensity ${s1}`).toArray();\n        const arr2 = data.getSeries(`LFQ intensity ${s2}`).toArray();\n        // calculate array of deltas\n        const deltas = jstat(\n            // array of indices 0...N\n            [...Array(arr1.length).keys()]\n                // filter to get indices of proteins that are not NaN in both\n                // samples\n                .filter((i) => !isNaN(arr1[i]) && !isNaN(arr2[i]))\n                // calculate delta for each index as difference / mean\n                .map((i) => (arr1[i] - arr2[i]) / ((arr1[i] + arr2[i]) / 2))\n        );\n        // calculate mean and standard deviation of deltas\n        const res = {\n            mean: deltas.mean(),\n            std: deltas.stdev(),\n        };\n\n        // put mean and standard deviation of deltas in cache and return\n        deltaCache.set(tuple(s1, s2), res);\n        return res;\n    };\n\n    // sort samples by number of NaN proteins, from lowest to highest (use this\n    // array to get the reference sample with the most non-NaN proteins)\n    const samplesByNumNotNaN = samples.sort(\n        (a, b) =>\n            data\n                .getSeries(`LFQ intensity ${a}`)\n                .select((val) => (isNaN(val) ? 1 : 0))\n                .sum() -\n            data\n                .getSeries(`LFQ intensity ${b}`)\n                .select((val) => (isNaN(val) ? 1 : 0))\n                .sum()\n    );\n\n    const imputedRelative = data\n        // do imputation for each protein\n        .select((row) => {\n            // count number of non-NaN replicates for this protein\n            const numNotNaN = Object.values(row)\n                .map((val) => (isNaN(val) ? 0 : 1))\n                .reduce((acc, val) => acc + val);\n            // only do imputation if protein is not NaN in >= `replicates`\n            // replicates\n            if (numNotNaN < replicates) return row;\n\n            // get reference sample by looping through samples (sorted by\n            // number of non-NaN proteins, starting with highest) and choosing\n            // first sample that is not NaN for this protein\n            let refSample;\n            for (let s of samplesByNumNotNaN) {\n                if (!isNaN(row[`LFQ intensity ${s}`])) {\n                    refSample = s;\n                    break;\n                }\n            }\n\n            // get mean correlation between selected reference sample and all\n            // samples which are NaN for this protein\n            const meanCorr = jstat(\n                samples\n                    .filter(\n                        (sample) =>\n                            sample !== refSample &&\n                            isNaN(row[`LFQ intensity ${sample}`])\n                    )\n                    .map((sample) => corr(sample, refSample))\n            ).mean();\n\n            // loop through all samples for this protein\n            return samples.reduce((obj, sample) => {\n                const val = row[`LFQ intensity ${sample}`];\n                if (isNaN(val)) {\n                    // if sample is NaN for this protein, do imputation by\n                    // getting distribution of deltas between sample and the\n                    // reference sample\n                    const { mean: Dmean, std: Dstd } = delta(sample, refSample);\n                    // draw new delta value from normal distribution\n                    const Dnew = random.normal(\n                        Dmean,\n                        Dstd / (Math.sqrt(2) * meanCorr)\n                    )();\n                    // calculate new intensity value and put in new row\n                    obj[`LFQ intensity ${sample}`] =\n                        row[`LFQ intensity ${refSample}`] * Math.abs(1 + Dnew);\n                } else {\n                    // if sample is not NaN for this protein, copy over the\n                    // value\n                    obj[`LFQ intensity ${sample}`] = val;\n                }\n                return obj;\n            }, {});\n        })\n        .bake();\n\n    // do uniform imputation to fill in remaining NaN values\n    const imputedUniform = imputeUniform(data, samples).subset(\n        samples.map((sample) => `LFQ intensity ${sample}`)\n    );\n\n    return (\n        imputedRelative\n            // loop through rows of relative and uniform imputation results\n            .zip(imputedUniform, (rowRel, rowUnif) => {\n                // use relative imputed row if there are no NaN values\n                const useRel = Object.values(rowRel).every(\n                    (val) => !isNaN(val)\n                );\n                return useRel ? rowRel : rowUnif;\n            })\n            .bake()\n    );\n}\n\n/**\n * Do two-step imputation strategy with relative imputation for proteins\n * detected in >= `replicate` replicates, and uniform imputation for proteins\n * detected in < `replicate` replicates.\n * @param {DataFrame} data DataFrame containing intensity data\n * @param {Map<string, string[]>} conditions map from each condition to array\n * of sample names of replicates\n * @param {number} replicates minimum number of replicates in which protein is\n * detected to use relative imputation\n */\nexport function imputeRelative(data, conditions, replicates = 2) {\n    // store columns with imputated data\n    const columnSpec = {};\n    conditions.forEach((samples, condition, m) => {\n        // do relative imputation for the samples of each condition\n        const result = imputeConditionRelative(\n            // pass only columns for samples of this condition\n            data.subset(samples.map((sample) => `LFQ intensity ${sample}`)),\n            samples,\n            replicates\n        );\n        // store resulting columns in the columnSpec object\n        for (const column of result.getColumns())\n            columnSpec[column.name] = column.series;\n    });\n\n    return new DataFrame({\n        columns: {\n            // copy common columns from current dataframe\n            ...MSExperiment.COMMON_COLUMNS.reduce(\n                (obj, column) =>\n                    Object.assign(obj, {\n                        [column]: data.getSeries(column),\n                    }),\n                {}\n            ),\n            // imputed data columns\n            ...columnSpec,\n        },\n        index: data.getIndex(),\n    }).bake();\n}\n","import { DataFrame, Series } from \"data-forge\";\nimport jstat from \"jstat\";\nimport { pAdjust, ttest } from \"./utils\";\nimport * as Imputation from \"./Imputation\";\n\nclass MSExperiment {\n    /**\n     *\n     * @param {DataFrame} data\n     * @param {string[]} samples\n     */\n    constructor(data, samples) {\n        this.data = data;\n        this.rawData = data;\n        this.samples = samples;\n\n        /** @type {Map<string, DataFrame} */\n        this.snapshots = new Map();\n\n        /** @type {Map<string, string[]>} */\n        this.replicates = new Map();\n\n        /** @type {Map<string, Map<string, DataFrame>>} */\n        this.comparisons = new Map();\n\n        this.removeContaminants = this.removeContaminants.bind(this);\n        this.logTransform = this.logTransform.bind(this);\n        this.removeAllNaN = this.removeAllNaN.bind(this);\n        this.setReplicates = this.setReplicates.bind(this);\n    }\n\n    static SNAPSHOT_KEYS = {\n        REMOVE_CONTAMINANTS: \"REMOVE_CONTAMINANTS\",\n        LOG_TRANSFORM: \"LOG_TRANSFORM\",\n        MEDIAN_NORMALIZATION: \"MEDIAN_NORMALIZATION\",\n        IMPUTE_MISSING_VALUES: \"IMPUTE_MISSING_VALUES\",\n    };\n\n    resetToSnapshot(key) {\n        if (this.snapshots.has(key)) this.data = this.snapshots.get(key);\n    }\n\n    static COMMON_COLUMNS = [\"id\", \"uniprotID\", \"gene\"];\n\n    static IMPUTATION_METHODS = {\n        METHOD_31: \"METHOD_31\",\n        METHOD_46: \"METHOD_46\",\n        METHOD_47: \"METHOD_47\",\n    };\n\n    /**\n     * Modifies `data` to remove entries with True for \"Potential contaminant\"\n     * or \"Reverse\"\n     */\n    removeContaminants() {\n        console.log(\"removing contaminants\");\n        this.data = this.data\n            // filter by \"Potential contaminant\" and \"Reverse\"\n            .where((row) => !row[\"Potential contaminant\"] && !row[\"Reverse\"])\n            // keep only common columns and \"LFQ intensity ...\" columns\n            .subset([\n                ...MSExperiment.COMMON_COLUMNS,\n                ...this.samples.map((sample) => `LFQ intensity ${sample}`),\n            ])\n            .bake();\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.REMOVE_CONTAMINANTS,\n            this.data\n        );\n    }\n\n    /**\n     * Modifies `data` with log2\n     */\n    logTransform() {\n        console.log(\"log transforming\");\n        this.data = new DataFrame({\n            columns: {\n                // copy common columns from current dataframe\n                ...MSExperiment.COMMON_COLUMNS.reduce(\n                    (obj, column) =>\n                        Object.assign(obj, {\n                            [column]: this.data.getSeries(column),\n                        }),\n                    {}\n                ),\n                // log transform LFQ intensity columns\n                ...this.samples.reduce(\n                    (obj, sample) =>\n                        Object.assign(obj, {\n                            [`LFQ intensity ${sample}`]: this.data\n                                .getSeries(`LFQ intensity ${sample}`)\n                                .select((value) =>\n                                    // set to NaN if LFQ intensity is not\n                                    // positive\n                                    value > 0 ? Math.log2(value) : NaN\n                                ),\n                        }),\n                    {}\n                ),\n            },\n            index: this.data.getIndex(),\n        }).bake();\n    }\n\n    /**\n     * Modifies `data` to remove entries with NaN in all samples (i.e.\n     * intensity of 0 in all samples)\n     */\n    removeAllNaN() {\n        console.log(\"removing all NaN\");\n        this.data = this.data\n            // only keep rows where not every sample is NaN\n            .where(\n                (row) =>\n                    !this.samples.every((sample) =>\n                        isNaN(row[`LFQ intensity ${sample}`])\n                    )\n            )\n            .bake();\n\n        this.snapshots.set(MSExperiment.SNAPSHOT_KEYS.LOG_TRANSFORM, this.data);\n    }\n\n    /**\n     * Modifies `data` such that each sample is scaled to have the same median\n     * value, equal to the highest median pre-scaling.\n     */\n    normalizeMedians(normalize) {\n        console.log(\"normalizing medians\");\n\n        if (!normalize) {\n            this.snapshots.set(\n                MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION,\n                this.data\n            );\n            return;\n        }\n\n        // calculate medians of each sample and store in map\n        /** @type {Map<string, number>} */\n        const medians = new Map();\n        this.samples.map((sample) =>\n            medians.set(\n                sample,\n                this.data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .where((value) => !Number.isNaN(value))\n                    .median()\n            )\n        );\n        const maxMedian = Math.max.apply(null, Array.from(medians.values()));\n\n        this.data = new DataFrame({\n            columns: {\n                // copy common columns from current dataframe\n                ...MSExperiment.COMMON_COLUMNS.reduce(\n                    (obj, column) =>\n                        Object.assign(obj, {\n                            [column]: this.data.getSeries(column),\n                        }),\n                    {}\n                ),\n                // median normalize LFQ intensity columns\n                ...this.samples.reduce(\n                    (obj, sample) =>\n                        Object.assign(obj, {\n                            [`LFQ intensity ${sample}`]: this.data\n                                .getSeries(`LFQ intensity ${sample}`)\n                                .select(\n                                    // scale each sample intensity so that\n                                    // sample median matches the maximum sample\n                                    // median\n                                    (value) =>\n                                        (value * maxMedian) /\n                                        medians.get(sample)\n                                ),\n                        }),\n                    {}\n                ),\n            },\n            index: this.data.getIndex(),\n        }).bake();\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION,\n            this.data\n        );\n    }\n\n    /**\n     * Modifies `replicates` to store group replicate samples into conditions\n     * @param {Object.<string, string[]>} replicates object containing\n     * replicate data, where keys are condition names and values are arrays of\n     * sample names\n     */\n    setReplicates(replicates) {\n        this.replicates.clear();\n        for (const [condition, samples] of Object.entries(replicates))\n            this.replicates.set(condition, samples);\n    }\n\n    /**\n     * Modifies `data` to replace NA's (intensity of 0) with imputed values.\n     * Imputed values are drawn from a uniform distribution of log2 intensities\n     * ranging from -3 * sigma to -2 * sigma among non-NA log2 intensity\n     * values within the same sample.\n     */\n    imputeMissingValues(method) {\n        console.log(\"imputing missing values\");\n\n        switch (method) {\n            case MSExperiment.IMPUTATION_METHODS.METHOD_31:\n                this.data = Imputation.imputeUniform(this.data, this.samples);\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_46:\n                this.data = Imputation.imputeRelative(\n                    this.data,\n                    this.replicates\n                );\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_47:\n                this.data = Imputation.imputeRelative(\n                    this.data,\n                    this.replicates,\n                    1\n                );\n        }\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES,\n            this.data\n        );\n    }\n\n    /**\n     * Makes specified comparisons and stores results in `comparisons.\n     * @param {Object.<string, string[]>} comparisons object containing\n     * comparisons to make, with condition A as key and condition B in values\n     * array\n     */\n    makeComparisons(comparisons) {\n        console.log(\"making comparisons\");\n        // loop through comparisons and set up `comparisons` map\n        for (const [conditionA, value] of Object.entries(comparisons)) {\n            if (!this.comparisons.has(conditionA))\n                this.comparisons.set(conditionA, new Map());\n\n            for (const conditionB of value) {\n                const comparisonData = DataFrame.zip(\n                    // for conditionA and conditionB, zip LFQ intensity columns\n                    // to make a column containing arrays of intensities from\n                    // replicates for that condition\n                    [conditionA, conditionB].map((condition) =>\n                        DataFrame.zip(\n                            this.replicates\n                                .get(condition)\n                                .map((sample) =>\n                                    this.data.getSeries(\n                                        `LFQ intensity ${sample}`\n                                    )\n                                ),\n                            // zip multiple replicate columns into single\n                            // column containing array of values\n                            (values) => values.toArray()\n                        )\n                    ),\n                    // zip conditionA and conditionB columns of arrays arrA and\n                    // arrB\n                    ([arrA, arrB]) => {\n                        // calculate means of conditionA and conditionB\n                        // intensities\n                        const meanA = jstat(arrA).mean();\n                        const meanB = jstat(arrB).mean();\n                        // perform two-sample two-tailed t test (Welch) using\n                        // arrays of intensities to get p value\n                        const pvalue = ttest(arrA, arrB).p;\n                        return {\n                            [`mean ${conditionA}`]: meanA,\n                            [`mean ${conditionB}`]: meanB,\n                            \"log FC\": meanB - meanA,\n                            \"p value\": pvalue,\n                        };\n                    }\n                )\n                    // copy common columns\n                    .withSeries(\n                        MSExperiment.COMMON_COLUMNS.reduce(\n                            (obj, column) =>\n                                Object.assign(obj, {\n                                    [column]: this.data.getSeries(column),\n                                }),\n                            {}\n                        )\n                    )\n                    .withIndex(this.data.getIndex())\n                    .bake()\n                    .withSeries({\n                        \"adjusted p value\": (df) =>\n                            new Series({\n                                index: df.getIndex(),\n                                values: pAdjust(\n                                    df.getSeries(\"p value\").toArray()\n                                ),\n                            }),\n                    })\n                    .bake();\n\n                // put comparison dataframe into `comparisons` map\n                this.comparisons\n                    .get(conditionA)\n                    .set(conditionB, comparisonData);\n            }\n        }\n    }\n}\n\nexport default MSExperiment;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputImputation.css\";\nimport { onImpute } from \"../RunAnalysis\";\nimport MSExperiment from \"../analysis/MSExperiment\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputImputation({ onImputeClick }) {\n    const [imputationModalOpen, setImputationModalOpen] = React.useState(false);\n    const [options, setOptions] = React.useState({\n        normalize: true,\n        method: MSExperiment.IMPUTATION_METHODS.METHOD_31,\n    });\n\n    const onOKClick = () => {\n        onImputeClick(options);\n        setImputationModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(3) </span>\n            <button onClick={() => setImputationModalOpen(true)}>\n                Preprocess and impute\n            </button>\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions before and\n                    after imputation as violin plot or boxplot.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={imputationModalOpen}\n                id=\"input-imputation-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-imputation-modal-head\">Imputation options</h1>\n\n                <div id=\"input-imputation-modal-body\">\n                    <h2>Pre-processing</h2>\n                    <input\n                        type=\"checkbox\"\n                        id=\"normalizeMedians\"\n                        checked={options.normalize}\n                        onChange={(e) =>\n                            setOptions(\n                                Object.assign({}, options, {\n                                    normalize: e.target.checked,\n                                })\n                            )\n                        }\n                    />\n                    <label htmlFor=\"normalizeMedians\">Normalize medians</label>\n                    <h2>Imputation</h2>\n                    <select\n                        onChange={(e) =>\n                            setOptions(\n                                Object.assign({}, options, {\n                                    method: e.currentTarget.value,\n                                })\n                            )\n                        }\n                    >\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_31}\n                        >\n                            method 3.1\n                        </option>\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_46}\n                        >\n                            method 4.6\n                        </option>\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_47}\n                        >\n                            method 4.7\n                        </option>\n                    </select>\n                </div>\n\n                <div id=\"input-replicate-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {};\n    },\n    (dispatch) => {\n        return {\n            onImputeClick: (options) => {\n                dispatch(onImpute(options));\n            },\n        };\n    }\n)(InputImputation);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputComparisonSelection.css\";\nimport { onComparisonsSelect } from \"../RunAnalysis\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputComparisonSelection({ conditions, onComparisonSelect }) {\n    const [comparisonModalOpen, setComparisonModalOpen] = React.useState(false);\n    /** @type {Map.<string, Set<string>} */\n    const comparisons = new Map();\n\n    const onComparisonChange = (conditionA, conditionB, selected) => {\n        if (selected) {\n            if (!comparisons.has(conditionA))\n                comparisons.set(conditionA, new Set());\n            comparisons.get(conditionA).add(conditionB);\n        } else {\n            if (\n                comparisons.has(conditionA) &&\n                comparisons.get(conditionA).has(conditionB)\n            )\n                comparisons.get(conditionA).delete(conditionB);\n        }\n    };\n\n    const onOKClick = () => {\n        onComparisonSelect(comparisons);\n        setComparisonModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(4) </span>\n            <button onClick={() => setComparisonModalOpen(true)}>\n                Select comparisons\n            </button>\n\n            <ul>\n                <li>\n                    View enriched and depleted proteins per comparison as\n                    volcano plot.\n                </li>\n                <li>View distribution of p values and adjusted p values.</li>\n                <li>\n                    View mean intensities, log fold changes, p values as data\n                    table.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={comparisonModalOpen}\n                id=\"input-comparison-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-comparison-modal-head\">Select comparisons</h1>\n\n                <table>\n                    <tbody>\n                        <tr>\n                            <td></td>\n                            {conditions.map((condition) => (\n                                <td key={`${condition} B`}>{condition}</td>\n                            ))}\n                        </tr>\n                        {conditions.map((conditionA) => (\n                            <tr key={`${conditionA} row`}>\n                                <td key={`${conditionA} A`}>{conditionA}</td>\n                                {conditions.map((conditionB) => (\n                                    <td key={`${conditionA},${conditionB}`}>\n                                        <input\n                                            type=\"checkbox\"\n                                            onChange={(e) =>\n                                                onComparisonChange(\n                                                    conditionA,\n                                                    conditionB,\n                                                    e.target.checked\n                                                )\n                                            }\n                                            disabled={conditionA === conditionB}\n                                        />\n                                    </td>\n                                ))}\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n\n                <div id=\"input-comparison-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {\n            conditions: state.input.conditions,\n        };\n    },\n    (dispatch) => {\n        return {\n            onComparisonSelect: (comparisons) => {\n                const comparisonsObj = Array.from(comparisons.keys()).reduce(\n                    (obj, condition) =>\n                        Object.assign(obj, {\n                            [condition]: Array.from(comparisons.get(condition)),\n                        }),\n                    {}\n                );\n                dispatch(onComparisonsSelect(comparisonsObj));\n            },\n        };\n    }\n)(InputComparisonSelection);\n","import \"./InputContainer.css\";\nimport InputDataUpload from \"./InputDataUpload\";\nimport InputReplicateSelection from \"./InputReplicateSelection\";\nimport InputImputation from \"./InputImputation\";\nimport InputComparisonSelection from \"./InputComparisonSelection\";\n\nfunction InputContainer({ id }) {\n    return (\n        <div id={id} className=\"input-container\">\n            <InputDataUpload />\n            <InputReplicateSelection />\n            <InputImputation />\n            <InputComparisonSelection />\n        </div>\n    );\n}\n\nexport default InputContainer;\n","import worker from \"./AnalysisWorker\";\nimport MSExperiment from \"./analysis/MSExperiment\";\n\nexport const FIGURES = {\n    LOG_VIOLIN: \"LOG_VIOLIN\",\n    PRE_POST_IMPUTATION_VIOLIN: \"PRE_POST_IMPUTATION_VIOLIN\",\n    PRE_POST_IMPUTATION_BOXPLOT: \"PRE_POST_IMPUTATION_BOXPLOT\",\n    VOLCANO: \"VOLCANO\",\n    P_VALUE_HISTOGRAM: \"P_VALUE_HISTOGRAM\",\n};\n\nexport async function makePlotlyDataLayout(options) {\n    const { type } = options;\n\n    let ret = { data: [], layout: {} };\n    switch (type) {\n        case FIGURES.LOG_VIOLIN:\n            ret = await makeLogViolin(options);\n            break;\n        case FIGURES.PRE_POST_IMPUTATION_VIOLIN:\n            ret = await makePrePostImputationViolin(options);\n            break;\n        case FIGURES.PRE_POST_IMPUTATION_BOXPLOT:\n            ret = await makePrePostImputationBoxplot(options);\n            break;\n        case FIGURES.VOLCANO:\n            ret = await makeVolcanoPlot(options);\n            break;\n        case FIGURES.P_VALUE_HISTOGRAM:\n            ret = await makePValueHistogram(options);\n            break;\n    }\n    ret.layout.autosize = true;\n\n    return ret;\n}\n\nasync function makeLogViolin({ samples, conditions }) {\n    const makeViolinTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"violin\",\n            width: 1,\n            points: false,\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all(\n                samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.LOG_TRANSFORM\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                x: data,\n                                y0: sample,\n                                side: \"positive\",\n                            })\n                        )\n                )\n            ),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all(\n                conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                x: data,\n                                y0: condition,\n                                side: \"positive\",\n                            })\n                        )\n                )\n            ),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities\",\n        showlegend: false,\n        xaxis: {\n            title: \"log2 intensity\",\n        },\n        yaxis: {\n            automargin: true,\n        },\n    });\n    return ret;\n}\n\nasync function makePrePostImputationViolin({ samples, conditions }) {\n    const makeViolinTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"violin\",\n            width: 1,\n            points: false,\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all([\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"pre\",\n                                x: data,\n                                y0: sample,\n                                legendgroup: \"pre\",\n                                side: \"positive\",\n                            })\n                        )\n                ),\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"post\",\n                                x: data,\n                                y0: sample,\n                                legendgroup: \"post\",\n                                side: \"negative\",\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all([\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"pre\",\n                                x: data,\n                                y0: condition,\n                                legendgroup: \"pre\",\n                                side: \"positive\",\n                            })\n                        )\n                ),\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .IMPUTE_MISSING_VALUES\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"post\",\n                                x: data,\n                                y0: condition,\n                                legendgroup: \"post\",\n                                side: \"negative\",\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities pre- and post-imputation\",\n        xaxis: {\n            title: \"log2 intensity\",\n        },\n        yaxis: {\n            automargin: true,\n        },\n    });\n    return ret;\n}\n\nasync function makePrePostImputationBoxplot({ samples, conditions }) {\n    const makeBoxplotTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"box\",\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all([\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION\n                        )\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"pre\",\n                                y: data,\n                                x0: sample,\n                                legendgroup: \"pre\",\n                            })\n                        )\n                ),\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES\n                        )\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"post\",\n                                y: data,\n                                x0: sample,\n                                legendgroup: \"post\",\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all([\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"pre\",\n                                y: data,\n                                x0: condition,\n                                legendgroup: \"pre\",\n                            })\n                        )\n                ),\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .IMPUTE_MISSING_VALUES\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"post\",\n                                y: data,\n                                x0: condition,\n                                legendgroup: \"post\",\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities pre- and post-imputation\",\n        xaxis: {\n            automargin: true,\n        },\n        yaxis: {\n            title: \"log2 intensity\",\n        },\n        boxmode: \"group\",\n        boxgap: -1,\n        boxgroupgap: 0,\n    });\n    return ret;\n}\n\nasync function makeVolcanoPlot({ comparisons, highlightGenes }) {\n    if (!comparisons) return { data: [], layout: {} };\n    const highlightGeneSet = new Set(\n        (highlightGenes || []).map((g) => g.toLowerCase())\n    );\n    return {\n        data: [\n            await Promise.all([\n                worker.getComparisonData(comparisons, \"log FC\"),\n                worker.getComparisonData(comparisons, \"adjusted p value\"),\n                worker.getComparisonData(comparisons, \"gene\"),\n            ]).then(([logfc, pvalues, genes]) => {\n                return {\n                    type: \"scattergl\",\n                    mode: \"markers\",\n                    x: logfc,\n                    y: pvalues.map((p) => -1 * Math.log10(p)),\n                    hovertext: genes,\n                    marker: {\n                        color: genes.map((g) =>\n                            highlightGeneSet.has(g.toLowerCase()) ? 1 : 0\n                        ),\n                    },\n                };\n            }),\n        ],\n        layout: {\n            title: `${comparisons[1]} vs. ${comparisons[0]}`,\n            xaxis: {\n                title: `log2 (${comparisons[1]} / ${comparisons[0]})`,\n            },\n            yaxis: {\n                title: \"-log10 (p_adjusted)\",\n            },\n        },\n    };\n}\n\nasync function makePValueHistogram({ comparisons }) {\n    if (!comparisons) return { data: [], layout: {} };\n    return {\n        data: [\n            {\n                type: \"histogram\",\n                name: \"p value\",\n                x: await worker.getComparisonData(comparisons, \"p value\"),\n                opacity: 0.5,\n                xbins: {\n                    start: 0,\n                    end: 1,\n                    size: 0.025,\n                },\n            },\n            {\n                type: \"histogram\",\n                name: \"adjusted p value\",\n                x: await worker.getComparisonData(\n                    comparisons,\n                    \"adjusted p value\"\n                ),\n                opacity: 0.5,\n                xbins: {\n                    start: 0,\n                    end: 1,\n                    size: 0.025,\n                },\n            },\n        ],\n        layout: {\n            title: `${comparisons[1]} vs. ${comparisons[0]} p values`,\n            barmode: \"overlay\",\n            xaxis: {\n                title: \"p\",\n            },\n            yaxis: {\n                title: \"count\",\n            },\n        },\n    };\n}\n","import React from \"react\";\nimport Plot from \"react-plotly.js\";\nimport { connect } from \"react-redux\";\nimport { makePlotlyDataLayout } from \"../Figures\";\n\nfunction MainPanelContainer({ id, figureOptions }) {\n    const [plot, setPlot] = React.useState({\n        data: [],\n        layout: {\n            autosize: true,\n        },\n    });\n\n    React.useEffect(async () => {\n        if (figureOptions) setPlot(await makePlotlyDataLayout(figureOptions));\n    }, [figureOptions]);\n\n    if (plot) {\n        return (\n            <div id={id} className=\"main-container\">\n                <Plot\n                    className=\"main-plot\"\n                    data={plot.data}\n                    layout={plot.layout}\n                    useResizeHandler\n                    style={{\n                        width: \"100%\",\n                        height: \"100%\",\n                    }}\n                    divId=\"mainpanel-figure\"\n                />\n            </div>\n        );\n    }\n    return \"loading...\";\n}\n\nexport default connect((state) => {\n    return {\n        figureOptions: state.view.figureOptions,\n    };\n}, null)(MainPanelContainer);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport worker from \"../AnalysisWorker\";\n\nimport MUIDataTable from \"mui-datatables\";\n\nfunction SidePanelContainer({ id, samples, figureOptions }) {\n    const [data, setData] = React.useState();\n\n    React.useEffect(async () => {\n        if (figureOptions.comparisons)\n            setData(\n                await worker.getComparisonsTable(figureOptions.comparisons)\n            );\n    }, [figureOptions.comparisons]);\n\n    return (\n        <div id={id}>\n            <MUIDataTable\n                title={\n                    figureOptions.comparisons\n                        ? `${figureOptions.comparisons[1]} vs. ${figureOptions.comparisons[0]}`\n                        : \"no data: make and select a comparison\"\n                }\n                data={data}\n                columns={data ? Object.keys(data[0]) : []}\n                options={{\n                    selectableRows: \"none\",\n                }}\n            />\n        </div>\n    );\n}\n\nexport default connect((state) => {\n    return {\n        figureOptions: state.view.figureOptions,\n    };\n}, null)(SidePanelContainer);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { FIGURES } from \"../Figures\";\n\nimport \"./FigureOptions.css\";\n\nfunction FigureOptions({\n    samples,\n    conditions,\n    comparisons,\n    figureType,\n    onOptionsChange,\n}) {\n    const [sampleCondition, setSampleCondition] = React.useState(\"samples\");\n\n    let options;\n    switch (figureType) {\n        case FIGURES.LOG_VIOLIN:\n        case FIGURES.PRE_POST_IMPUTATION_VIOLIN:\n        case FIGURES.PRE_POST_IMPUTATION_BOXPLOT:\n            const onFigureTypeChange = (e) => {\n                setSampleCondition(e.currentTarget.value);\n                onOptionsChange({\n                    samples: undefined,\n                    conditions: undefined,\n                });\n            };\n\n            options = (\n                <>\n                    <div>\n                        <input\n                            type=\"radio\"\n                            id=\"figureTypeSamples\"\n                            name=\"figureType\"\n                            value=\"samples\"\n                            checked={sampleCondition === \"samples\"}\n                            onChange={onFigureTypeChange}\n                        />\n                        <label htmlFor=\"figureTypeSamples\">Samples</label>\n                        <br />\n                        <input\n                            type=\"radio\"\n                            id=\"figureTypeConditions\"\n                            name=\"figureType\"\n                            value=\"conditions\"\n                            checked={sampleCondition === \"conditions\"}\n                            onChange={onFigureTypeChange}\n                        />\n                        <label htmlFor=\"figureTypeConditions\">Conditions</label>\n                    </div>\n                    <select\n                        className=\"sample-condition-selector\"\n                        multiple\n                        onChange={(e) => {\n                            onOptionsChange({\n                                [sampleCondition]: Array.from(\n                                    e.target.selectedOptions\n                                ).map((opt) => opt.value),\n                            });\n                        }}\n                    >\n                        {{ samples, conditions }[sampleCondition].map(\n                            (name) => (\n                                <option value={name} key={name}>\n                                    {name}\n                                </option>\n                            )\n                        )}\n                    </select>\n                </>\n            );\n            break;\n        case FIGURES.VOLCANO:\n        case FIGURES.P_VALUE_HISTOGRAM:\n            options = (\n                <>\n                    <select\n                        className=\"comparison-selector\"\n                        multiple\n                        onChange={(e) => {\n                            onOptionsChange({\n                                comparisons: JSON.parse(e.target.value),\n                            });\n                        }}\n                    >\n                        {Object.entries(comparisons || {})\n                            .map(([conditionA, value]) =>\n                                value.map((conditionB) => (\n                                    <option\n                                        value={JSON.stringify([\n                                            conditionA,\n                                            conditionB,\n                                        ])}\n                                        key={JSON.stringify([\n                                            conditionA,\n                                            conditionB,\n                                        ])}\n                                    >\n                                        {conditionB} vs. {conditionA}\n                                    </option>\n                                ))\n                            )\n                            .flat()}\n                    </select>\n                    <textarea\n                        className=\"highlight-genes-textbox\"\n                        placeholder=\"highlight genes in volcano plot (case insensitive); one gene per line\"\n                        onChange={(e) =>\n                            onOptionsChange({\n                                highlightGenes: e.target.value\n                                    .split(\"\\n\")\n                                    .filter((g) => g !== \"\"),\n                            })\n                        }\n                    ></textarea>\n                </>\n            );\n            break;\n    }\n\n    return <div className=\"figure-sample-condition-selector\">{options}</div>;\n}\n\nexport default connect((state) => {\n    return {\n        samples: state.input.samples,\n        conditions: state.input.conditions,\n        comparisons: state.input.comparisons,\n    };\n}, null)(FigureOptions);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { FIGURES } from \"../Figures\";\nimport { downloadData, saveFigure } from \"../RunAnalysis\";\nimport { ACTIONS, createAction } from \"../store/actions\";\n\nimport FigureOptions from \"./FigureOptions\";\n\nimport \"./ViewContainer.css\";\n\nfunction ViewContainer({ id, onOptionsSet, onDownloadClick, onSavePlotClick }) {\n    const [figureOptions, setFigureOptions] = React.useState({});\n\n    return (\n        <div id={id} className=\"view-container\">\n            <p>Select data to view.</p>\n            <div className=\"figure-options\">\n                {/* select figure type */}\n                <select\n                    onChange={(e) => {\n                        setFigureOptions(\n                            Object.assign({}, figureOptions, {\n                                type: e.target.value,\n                            })\n                        );\n                    }}\n                    defaultValue=\"default\"\n                >\n                    {[\n                        <option disabled value=\"default\" key=\"default\">\n                            -- select an option --\n                        </option>,\n                        ...Object.keys(FIGURES).map((fig) => (\n                            <option value={fig} key={fig}>\n                                {fig}\n                            </option>\n                        )),\n                    ]}\n                </select>\n\n                {/* select figure options */}\n                <FigureOptions\n                    figureType={figureOptions.type}\n                    onOptionsChange={(changedOptions) =>\n                        setFigureOptions(\n                            Object.assign({}, figureOptions, changedOptions)\n                        )\n                    }\n                />\n\n                {/* set options */}\n                <button onClick={() => onOptionsSet(figureOptions)}>\n                    View data\n                </button>\n\n                <button onClick={onDownloadClick}>Download data</button>\n                <button onClick={onSavePlotClick}>Download figure</button>\n            </div>\n        </div>\n    );\n}\n\nexport default connect(null, (dispatch) => {\n    return {\n        onOptionsSet: (figureOptions) => {\n            dispatch(\n                createAction(ACTIONS.SET_VIEW_FIGURE_OPTIONS, figureOptions)\n            );\n        },\n        onDownloadClick: () => {\n            dispatch(downloadData());\n        },\n        onSavePlotClick: () => {\n            dispatch(saveFigure());\n        },\n    };\n})(ViewContainer);\n","import \"./App.css\";\nimport InputContainer from \"./InputContainer\";\nimport MainPanelContainer from \"./MainPanelContainer\";\nimport SidePanelContainer from \"./SidePanelContainer\";\nimport ViewContainer from \"./ViewContainer.js\";\n\nfunction App() {\n    return (\n        <div id=\"app-container\">\n            <InputContainer id=\"input-container\" />\n            <ViewContainer id=\"view-container\" />\n            <SidePanelContainer id=\"sidepanel-container\" />\n            <MainPanelContainer id=\"mainpanel-container\" />\n        </div>\n    );\n}\n\nexport default App;\n","import { applyMiddleware, createStore, compose } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport { ACTIONS } from \"./actions\";\n\nconst initialState = {\n    input: {\n        samples: [],\n        conditions: [],\n    },\n    view: {\n        figureOptions: {},\n    },\n    side: {},\n    main: {},\n};\n\nfunction inputReducer(state, action) {\n    switch (action.type) {\n        case ACTIONS.SET_INPUT_SAMPLES:\n            return Object.assign({}, state, {\n                samples: action.data,\n            });\n        case ACTIONS.SET_INPUT_CONDITIONS:\n            return Object.assign({}, state, {\n                conditions: action.data,\n            });\n        case ACTIONS.SET_INPUT_COMPARISONS:\n            return Object.assign({}, state, {\n                comparisons: action.data,\n            });\n    }\n    return state;\n}\n\nfunction viewReducer(state, action) {\n    switch (action.type) {\n        case ACTIONS.SET_VIEW_FIGURE_OPTIONS:\n            return Object.assign({}, state, {\n                figureOptions: action.data,\n            });\n    }\n    return state;\n}\n\nfunction rootReducer(state = initialState, action) {\n    const cpy = { ...state };\n    switch (action.type) {\n        case ACTIONS.SET_INPUT_SAMPLES:\n        case ACTIONS.SET_INPUT_CONDITIONS:\n        case ACTIONS.SET_INPUT_COMPARISONS:\n            cpy.input = inputReducer(state.input, action);\n            break;\n        case ACTIONS.SET_VIEW_FIGURE_OPTIONS:\n            cpy.view = viewReducer(state.view, action);\n            break;\n    }\n    return cpy;\n}\n\nconst composeEnhancers =\n    (typeof window !== \"undefined\" &&\n        window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n    compose;\n\nexport default createStore(\n    rootReducer,\n    composeEnhancers(applyMiddleware(thunk))\n);\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport store from \"./store/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <Provider store={store}>\n            <App />\n        </Provider>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals(console.log);\n"],"sourceRoot":""}