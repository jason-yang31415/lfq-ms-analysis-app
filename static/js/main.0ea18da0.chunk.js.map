{"version":3,"sources":["AnalysisWorker.js","worker.js","store/actions.js","store/store.js","PyAnalysis.js","analysis/utils.js","analysis/Imputation.js","analysis/MSExperiment.js","Figures.js","RunAnalysis.js","components/InputDataUpload.js","components/InputReplicateSelection.js","components/InputImputation.js","components/InputComparisonSelection.js","components/InputContainer.js","python/init_figure.py","components/MainPanelContainer.js","components/ReplOutput.js","components/SidePanelContainer.js","components/FigureOptions.js","components/ViewContainer.js","components/App.js","index.js"],"names":["worker","wrap","Worker","ACTIONS","createAction","type","data","initialState","input","samples","conditions","view","figureOptions","side","main","repl","inputReducer","state","action","Object","assign","comparisons","viewReducer","replReducer","index","length","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","cpy","applyMiddleware","thunk","_py","ready","loadPyodide","indexURL","then","pyodide","py","loadPackage","runPythonAsync","analysisThreadModule","get","name","getPythonWorker","registerJsModule","runPython","python","results","appendReplLog","toString","catch","err","runPythonWorker","transfers","transfer","asyncRun","error","pickle","context","code","store","dispatch","trim","ttest","arr1","arr2","m1","jstat","mean","m2","s1","stdev","s2","se","Math","sqrt","pow","df","floor","t","p","studentt","cdf","abs","pAdjust","pvalues","entries","map","sort","a","b","i","padj","min","entry","imputeUniform","DataFrame","columns","MSExperiment","COMMON_COLUMNS","reduce","obj","column","getSeries","sample","series","where","value","Number","isNaN","bake","average","std","select","random","uniform","getIndex","imputeConditionRelative","replicates","corrCache","Map","corr","has","tuple","toArray","arrNaN","Array","keys","c","corrcoeff","filter","v","max","set","deltaCache","delta","deltas","res","samplesByNumNotNaN","val","sum","imputedRelative","row","refSample","values","acc","s","meanCorr","Dmean","Dstd","Dnew","normal","imputedUniform","subset","zip","rowRel","rowUnif","every","imputeRelative","columnSpec","forEach","condition","m","result","getColumns","this","rawData","snapshots","removeContaminants","bind","logTransform","removeAllNaN","setReplicates","key","console","log","SNAPSHOT_KEYS","REMOVE_CONTAMINANTS","log2","NaN","LOG_TRANSFORM","normalize","medians","median","maxMedian","apply","from","MEDIAN_NORMALIZATION","clear","method","IMPUTATION_METHODS","METHOD_31","Imputation","METHOD_46","METHOD_47","IMPUTE_MISSING_VALUES","thresholdP","thresholdLogFC","thresholdReps","conditionA","conditionB","rawA","rawB","comparisonData","arrA","arrB","rowId","id","meanA","meanB","pvalue","countNonzeroReps","raw","at","withSeries","withIndex","Series","output","FIGURES","LOG_VIOLIN","PRE_POST_IMPUTATION_VIOLIN","PRE_POST_IMPUTATION_BOXPLOT","VOLCANO","P_VALUE_HISTOGRAM","makeLogViolin","src","undefined","x","join","makePrePostImputationViolin","makeVolcanoPlot","highlightGenes","g","makePValueHistogram","showPlot","options","makePlotCode","connect","onDataUpload","file","Response","arrayBuffer","ab","raw_data","htmlFor","onInput","e","target","files","Modal","setAppElement","onReplicatesSelect","React","useState","replicatesModalOpen","setReplicatesModalOpen","selectedReplicates","setSelectedReplicates","conditionName","setConditionName","setConditions","onClick","isOpen","style","overlay","zIndex","multiple","onChange","selectedOptions","opt","margin","onImputeClick","onImpute","imputationModalOpen","setImputationModalOpen","setOptions","checked","currentTarget","onComparisonSelect","thresholds","flat","onComparisonsSelect","comparisonModalOpen","setComparisonModalOpen","setThresholdP","setThresholdLogFC","setThresholdReps","setComparisons","selected","includes","push","splice","indexOf","onComparisonChange","disabled","step","InputContainer","className","MainPanelContainer","content","fetch","initFigure","text","setState","props","Component","replLog","tab","setTab","setData","setCode","useEffect","comparison","table","fromEntries","title","selectableRows","rows","figureType","onOptionsChange","sampleCondition","setSampleCondition","onFigureTypeChange","JSON","parse","stringify","placeholder","split","onOptionsSet","setFigureOptions","defaultValue","fig","changedOptions","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0ea18da0.chunk.js","sourcesContent":["/* eslint-disable import/no-webpack-loader-syntax */\nimport Worker from \"worker-loader!./worker.js\";\nimport { wrap } from \"comlink\";\n\n// instantiate worker for analysis\nconst worker = wrap(new Worker());\nexport default worker;\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/worker.d83e0d16.worker.js\");\n}\n","export const ACTIONS = {\n    SET_INPUT_SAMPLES: \"SET_INPUT_SAMPLES\",\n    SET_INPUT_CONDITIONS: \"SET_INPUT_CONDITIONS\",\n    SET_INPUT_COMPARISONS: \"SET_INPUT_COMPARISONS\",\n    SET_VIEW_FIGURE_OPTIONS: \"SET_VIEW_FIGURE_OPTIONS\",\n    APPEND_REPL_LOG: \"APPEND_REPL_LOG\",\n};\n\nexport function createAction(type, data) {\n    return {\n        type,\n        data,\n    };\n}\n","import { applyMiddleware, createStore, compose } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport { ACTIONS } from \"./actions\";\n\nconst initialState = {\n    input: {\n        samples: [],\n        conditions: [],\n    },\n    view: {\n        figureOptions: {},\n    },\n    side: {},\n    main: {},\n    repl: [],\n};\n\nfunction inputReducer(state, action) {\n    switch (action.type) {\n        case ACTIONS.SET_INPUT_SAMPLES:\n            return Object.assign({}, state, {\n                samples: action.data,\n            });\n        case ACTIONS.SET_INPUT_CONDITIONS:\n            return Object.assign({}, state, {\n                conditions: action.data,\n            });\n        case ACTIONS.SET_INPUT_COMPARISONS:\n            return Object.assign({}, state, {\n                comparisons: action.data,\n            });\n    }\n    return state;\n}\n\nfunction viewReducer(state, action) {\n    switch (action.type) {\n        case ACTIONS.SET_VIEW_FIGURE_OPTIONS:\n            return Object.assign({}, state, {\n                figureOptions: action.data,\n            });\n    }\n    return state;\n}\n\nfunction replReducer(state, action) {\n    switch (action.type) {\n        case ACTIONS.APPEND_REPL_LOG:\n            let index = state.length;\n            return [\n                ...state,\n                {\n                    index,\n                    ...action.data,\n                },\n            ];\n    }\n    return state;\n}\n\nfunction rootReducer(state = initialState, action) {\n    const cpy = { ...state };\n    switch (action.type) {\n        case ACTIONS.SET_INPUT_SAMPLES:\n        case ACTIONS.SET_INPUT_CONDITIONS:\n        case ACTIONS.SET_INPUT_COMPARISONS:\n            cpy.input = inputReducer(state.input, action);\n            break;\n        case ACTIONS.SET_VIEW_FIGURE_OPTIONS:\n            cpy.view = viewReducer(state.view, action);\n            break;\n        case ACTIONS.APPEND_REPL_LOG:\n            cpy.repl = replReducer(state.repl, action);\n            break;\n    }\n    return cpy;\n}\n\nconst composeEnhancers =\n    (typeof window !== \"undefined\" &&\n        window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n    compose;\n\nexport default createStore(\n    rootReducer,\n    composeEnhancers(applyMiddleware(thunk))\n);\n","import worker from \"./AnalysisWorker\";\nimport { transfer } from \"comlink\";\nimport store from \"./store/store\";\nimport { ACTIONS, createAction } from \"./store/actions\";\n\nconst PYODIDE_INDEX_URL = \"https://cdn.jsdelivr.net/pyodide/v0.17.0/full/\";\n\nlet _py = null;\n\nfunction initializePython() {\n    return window\n        .loadPyodide({\n            indexURL: PYODIDE_INDEX_URL,\n        })\n        .then((pyodide) => {\n            _py = pyodide;\n        })\n        .then(() => {\n            // TODO\n            return py().loadPackage([\n                \"matplotlib\",\n                \"pandas\",\n                \"numpy\",\n                \"scipy\",\n                \"statsmodels\",\n            ]);\n        })\n        .then(() => {\n            return py().runPythonAsync(`\nimport micropip\n\nawait micropip.install(\"/python/proteomics_analysis-0.0.1-py3-none-any.whl\")\nimport proteomics\nimport proteomics.plotting\nlfq_col = proteomics.util.lfq_col\n\nimport numpy as np\n            `);\n        })\n        .then(() => {\n            // initialize communication between plotting and analysis threads\n            const analysisThreadModule = {\n                // function accessible from python to get data from worker\n                // thread\n                get: (name) => {\n                    return getPythonWorker(name, true);\n                },\n            };\n            py().registerJsModule(\"analysis_thread\", analysisThreadModule);\n            return py().runPythonAsync(`\nimport pickle\nfrom analysis_thread import get\n\ndef get_from_analysis(name):\n    # get a variable from the analysis thread by pickling it on the analysis \n    # thread, transferring bytes to the plotting thread, and unpickling it\n    x = await get(name)\n    return pickle.loads(memoryview(bytes(x.to_py())))\n            `);\n        });\n}\n\nexport const ready = initializePython();\nexport function py() {\n    return _py;\n}\n\nexport function runPython(python) {\n    return ready\n        .then(() => py().runPythonAsync(python))\n        .then((results) => {\n            appendReplLog(\n                \"figure\",\n                python,\n                results ? results.toString() : null,\n                null\n            );\n        })\n        .catch((err) => {\n            appendReplLog(\"figure\", python, null, err ? err.toString() : null);\n        });\n}\n\nexport function runPythonWorker(python, data, transfers) {\n    if (transfers) data = transfer(data, transfers);\n    return worker\n        .asyncRun(python, data)\n        .then(({ results, error }) =>\n            appendReplLog(\"worker\", python, results, error)\n        );\n}\n\nexport function getPythonWorker(name, pickle = false) {\n    return worker.get(name, pickle);\n}\n\nfunction appendReplLog(context, code, results, error) {\n    store.dispatch(\n        createAction(ACTIONS.APPEND_REPL_LOG, {\n            context,\n            code: code.trim(),\n            results,\n            error,\n        })\n    );\n}\n","import jstat from \"jstat\";\n\n/**\n * Calculates two-sample Welch's t-test (two tail).\n * @param {number[]} arr1 sample 1\n * @param {number[]} arr2 sample 2\n */\nexport function ttest(arr1, arr2) {\n    const m1 = jstat(arr1).mean();\n    const m2 = jstat(arr2).mean();\n    const s1 = jstat(arr1).stdev(true);\n    const s2 = jstat(arr2).stdev(true);\n    const se = Math.sqrt(\n        Math.pow(s1, 2) / arr1.length + Math.pow(s2, 2) / arr2.length\n    );\n    const df = Math.floor(\n        Math.pow(\n            Math.pow(s1, 2) / arr1.length + Math.pow(s2, 2) / arr2.length,\n            2\n        ) /\n            (Math.pow(s1, 4) / (Math.pow(arr1.length, 2) * (arr1.length - 1)) +\n                Math.pow(s2, 4) /\n                    (Math.pow(arr2.length, 2) * (arr2.length - 1)))\n    );\n    const t = (m2 - m1) / se;\n    const p = 2 * jstat.studentt.cdf(-Math.abs(t), df);\n    return { t, p, df };\n}\n\n/**\n * Adjust p values using Benjamini-Hochberg method (FDR)\n * @param {number[]} pvalues array containing p values\n */\nexport function pAdjust(pvalues) {\n    // enumerate indices for original order, then sort by p value\n    const entries = pvalues\n        .map((p, index) => {\n            return { index, p };\n        })\n        .sort((a, b) => a.p - b.p);\n    // calculate BH corrected p value\n    for (let i = entries.length - 1; i >= 0; i--) {\n        entries[i].padj = Math.min(\n            1,\n            Math.min(\n                (entries.length * entries[i].p) / (i + 1),\n                i < entries.length - 1 ? entries[i + 1].padj : 1\n            )\n        );\n    }\n    // use original order (sort by index) then return adjusted p values\n    return entries.sort((a, b) => a.index - b.index).map((entry) => entry.padj);\n}\n","import { DataFrame, Series } from \"data-forge\";\nimport random from \"random\";\nimport MSExperiment from \"./MSExperiment\";\nimport jstat from \"jstat\";\nimport { tuple } from \"immutable-tuple\";\n\n/**\n * Do imputation from uniform distribution between sample mean - 3 * std to\n * mean - 2 * std\n * @param {DataFrame} data DataFrame containing intensity data\n * @param {string[]} samples names of samples\n */\nexport function imputeUniform(data, samples) {\n    return new DataFrame({\n        columns: {\n            // copy common columns from current dataframe\n            ...MSExperiment.COMMON_COLUMNS.reduce(\n                (obj, column) =>\n                    Object.assign(obj, {\n                        [column]: data.getSeries(column),\n                    }),\n                {}\n            ),\n            // perform imputation on LFQ intensity columns\n            ...samples.reduce((obj, sample) => {\n                // compute mean and standard deviation of non-NaN log\n                // intensity values for the sample\n                const series = data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .where((value) => !Number.isNaN(value))\n                    .bake();\n                const mean = series.average();\n                const stdev = series.std();\n                obj[`LFQ intensity ${sample}`] = data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .select(\n                        // replace NaN's with random values drawn from\n                        // uniform distribution\n                        (value) =>\n                            Number.isNaN(value)\n                                ? random.uniform(\n                                      mean - 3 * stdev,\n                                      mean - 2 * stdev\n                                  )()\n                                : value\n                    );\n                return obj;\n            }, {}),\n        },\n        index: data.getIndex(),\n    }).bake();\n}\n\n// minimum correlation\nconst MINIMUM_CORRELATION = 0.1;\n\n/**\n * Do relative imputation in a single condition.\n * @param {DataFrame} data DataFrame containing the relevant sample columns\n * @param {string[]} samples names of samples in the same condition\n * @param {number} replicates threshold number of replicates; do not impute if\n * the protein is detected in fewer than `replicate` replicates\n */\nfunction imputeConditionRelative(data, samples, replicates = 2) {\n    // calculate Pearson correlation coefficient between non-NaN values of two\n    // samples\n    const corrCache = new Map();\n    const corr = (s1, s2) => {\n        // return calculated correlation if already in cache\n        if (corrCache.has(tuple(s1, s2))) return corrCache.get(tuple(s1, s2));\n\n        // get sample values as arrays\n        const arr1 = data.getSeries(`LFQ intensity ${s1}`).toArray();\n        const arr2 = data.getSeries(`LFQ intensity ${s2}`).toArray();\n        // mask proteins with NaN in either sample: true if non-NaN in both\n        const arrNaN = [...Array(arr1.length).keys()].map(\n            (i) => !isNaN(arr1[i]) && !isNaN(arr2[i])\n        );\n\n        // calculate Pearson correlation coefficient\n        let c = jstat.corrcoeff(\n            // filter both arrays to only use proteins that are not NaN in both\n            // samples\n            arr1.filter((v, i) => arrNaN[i]),\n            arr2.filter((v, i) => arrNaN[i])\n        );\n        // use a minimum value for correlation\n        c = Math.max(isNaN(c) ? 0 : c, MINIMUM_CORRELATION);\n\n        // put correlation in cache and return\n        corrCache.set(tuple(s1, s2), c);\n        return c;\n    };\n\n    // calculate distribution of deltas between two samples\n    const deltaCache = new Map();\n    const delta = (s1, s2) => {\n        // return calculated mean and standard deviation on delta if already in\n        // cache\n        if (deltaCache.has(tuple(s1, s2))) return deltaCache.get(tuple(s1, s2));\n\n        // get sample values as arrays\n        const arr1 = data.getSeries(`LFQ intensity ${s1}`).toArray();\n        const arr2 = data.getSeries(`LFQ intensity ${s2}`).toArray();\n        // calculate array of deltas\n        const deltas = jstat(\n            // array of indices 0...N\n            [...Array(arr1.length).keys()]\n                // filter to get indices of proteins that are not NaN in both\n                // samples\n                .filter((i) => !isNaN(arr1[i]) && !isNaN(arr2[i]))\n                // calculate delta for each index as difference / mean\n                .map((i) => (arr1[i] - arr2[i]) / ((arr1[i] + arr2[i]) / 2))\n        );\n        // calculate mean and standard deviation of deltas\n        const res = {\n            mean: deltas.mean(),\n            std: deltas.stdev(),\n        };\n\n        // put mean and standard deviation of deltas in cache and return\n        deltaCache.set(tuple(s1, s2), res);\n        return res;\n    };\n\n    // sort samples by number of NaN proteins, from lowest to highest (use this\n    // array to get the reference sample with the most non-NaN proteins)\n    const samplesByNumNotNaN = samples.sort(\n        (a, b) =>\n            data\n                .getSeries(`LFQ intensity ${a}`)\n                .select((val) => (isNaN(val) ? 1 : 0))\n                .sum() -\n            data\n                .getSeries(`LFQ intensity ${b}`)\n                .select((val) => (isNaN(val) ? 1 : 0))\n                .sum()\n    );\n\n    const imputedRelative = data\n        // do imputation for each protein\n        .select((row) => {\n            // count number of non-NaN replicates for this protein\n            const numNotNaN = Object.values(row)\n                .map((val) => (isNaN(val) ? 0 : 1))\n                .reduce((acc, val) => acc + val);\n            // only do imputation if protein is not NaN in >= `replicates`\n            // replicates\n            if (numNotNaN < replicates) return row;\n\n            // get reference sample by looping through samples (sorted by\n            // number of non-NaN proteins, starting with highest) and choosing\n            // first sample that is not NaN for this protein\n            let refSample;\n            for (let s of samplesByNumNotNaN) {\n                if (!isNaN(row[`LFQ intensity ${s}`])) {\n                    refSample = s;\n                    break;\n                }\n            }\n\n            // get mean correlation between selected reference sample and all\n            // samples which are NaN for this protein\n            const meanCorr = jstat(\n                samples\n                    .filter(\n                        (sample) =>\n                            sample !== refSample &&\n                            isNaN(row[`LFQ intensity ${sample}`])\n                    )\n                    .map((sample) => corr(sample, refSample))\n            ).mean();\n\n            // loop through all samples for this protein\n            return samples.reduce((obj, sample) => {\n                const val = row[`LFQ intensity ${sample}`];\n                if (isNaN(val)) {\n                    // if sample is NaN for this protein, do imputation by\n                    // getting distribution of deltas between sample and the\n                    // reference sample\n                    const { mean: Dmean, std: Dstd } = delta(sample, refSample);\n                    // draw new delta value from normal distribution\n                    const Dnew = random.normal(\n                        Dmean,\n                        Dstd / (Math.sqrt(2) * meanCorr)\n                    )();\n                    // calculate new intensity value and put in new row\n                    obj[`LFQ intensity ${sample}`] =\n                        row[`LFQ intensity ${refSample}`] * Math.abs(1 + Dnew);\n                } else {\n                    // if sample is not NaN for this protein, copy over the\n                    // value\n                    obj[`LFQ intensity ${sample}`] = val;\n                }\n                return obj;\n            }, {});\n        })\n        .bake();\n\n    // do uniform imputation to fill in remaining NaN values\n    const imputedUniform = imputeUniform(data, samples).subset(\n        samples.map((sample) => `LFQ intensity ${sample}`)\n    );\n\n    return (\n        imputedRelative\n            // loop through rows of relative and uniform imputation results\n            .zip(imputedUniform, (rowRel, rowUnif) => {\n                // use relative imputed row if there are no NaN values\n                const useRel = Object.values(rowRel).every(\n                    (val) => !isNaN(val)\n                );\n                return useRel ? rowRel : rowUnif;\n            })\n            .bake()\n    );\n}\n\n/**\n * Do two-step imputation strategy with relative imputation for proteins\n * detected in >= `replicate` replicates, and uniform imputation for proteins\n * detected in < `replicate` replicates.\n * @param {DataFrame} data DataFrame containing intensity data\n * @param {Map<string, string[]>} conditions map from each condition to array\n * of sample names of replicates\n * @param {number} replicates minimum number of replicates in which protein is\n * detected to use relative imputation\n */\nexport function imputeRelative(data, conditions, replicates = 2) {\n    // store columns with imputated data\n    const columnSpec = {};\n    conditions.forEach((samples, condition, m) => {\n        // do relative imputation for the samples of each condition\n        const result = imputeConditionRelative(\n            // pass only columns for samples of this condition\n            data.subset(samples.map((sample) => `LFQ intensity ${sample}`)),\n            samples,\n            replicates\n        );\n        // store resulting columns in the columnSpec object\n        for (const column of result.getColumns())\n            columnSpec[column.name] = column.series;\n    });\n\n    return new DataFrame({\n        columns: {\n            // copy common columns from current dataframe\n            ...MSExperiment.COMMON_COLUMNS.reduce(\n                (obj, column) =>\n                    Object.assign(obj, {\n                        [column]: data.getSeries(column),\n                    }),\n                {}\n            ),\n            // imputed data columns\n            ...columnSpec,\n        },\n        index: data.getIndex(),\n    }).bake();\n}\n","import { DataFrame, Series } from \"data-forge\";\nimport jstat from \"jstat\";\nimport { pAdjust, ttest } from \"./utils\";\nimport * as Imputation from \"./Imputation\";\n\nclass MSExperiment {\n    /**\n     *\n     * @param {DataFrame} data\n     * @param {string[]} samples\n     */\n    constructor(data, samples) {\n        this.data = data;\n        this.rawData = data;\n        this.samples = samples;\n\n        /** @type {Map<string, DataFrame} */\n        this.snapshots = new Map();\n\n        /** @type {Map<string, string[]>} */\n        this.replicates = new Map();\n\n        /** @type {Map<string, Map<string, DataFrame>>} */\n        this.comparisons = new Map();\n\n        this.removeContaminants = this.removeContaminants.bind(this);\n        this.logTransform = this.logTransform.bind(this);\n        this.removeAllNaN = this.removeAllNaN.bind(this);\n        this.setReplicates = this.setReplicates.bind(this);\n    }\n\n    static SNAPSHOT_KEYS = {\n        REMOVE_CONTAMINANTS: \"REMOVE_CONTAMINANTS\",\n        LOG_TRANSFORM: \"LOG_TRANSFORM\",\n        MEDIAN_NORMALIZATION: \"MEDIAN_NORMALIZATION\",\n        IMPUTE_MISSING_VALUES: \"IMPUTE_MISSING_VALUES\",\n    };\n\n    resetToSnapshot(key) {\n        if (this.snapshots.has(key)) this.data = this.snapshots.get(key);\n    }\n\n    static COMMON_COLUMNS = [\"id\", \"uniprotID\", \"gene\"];\n\n    static IMPUTATION_METHODS = {\n        METHOD_31: \"METHOD_31\",\n        METHOD_46: \"METHOD_46\",\n        METHOD_47: \"METHOD_47\",\n    };\n\n    /**\n     * Modifies `data` to remove entries with True for \"Potential contaminant\"\n     * or \"Reverse\"\n     */\n    removeContaminants() {\n        console.log(\"removing contaminants\");\n        this.data = this.data\n            // filter by \"Potential contaminant\" and \"Reverse\"\n            .where((row) => !row[\"Potential contaminant\"] && !row[\"Reverse\"])\n            // keep only common columns and \"LFQ intensity ...\" columns\n            .subset([\n                ...MSExperiment.COMMON_COLUMNS,\n                ...this.samples.map((sample) => `LFQ intensity ${sample}`),\n            ])\n            .bake();\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.REMOVE_CONTAMINANTS,\n            this.data\n        );\n    }\n\n    /**\n     * Modifies `data` with log2\n     */\n    logTransform() {\n        console.log(\"log transforming\");\n        this.data = new DataFrame({\n            columns: {\n                // copy common columns from current dataframe\n                ...MSExperiment.COMMON_COLUMNS.reduce(\n                    (obj, column) =>\n                        Object.assign(obj, {\n                            [column]: this.data.getSeries(column),\n                        }),\n                    {}\n                ),\n                // log transform LFQ intensity columns\n                ...this.samples.reduce(\n                    (obj, sample) =>\n                        Object.assign(obj, {\n                            [`LFQ intensity ${sample}`]: this.data\n                                .getSeries(`LFQ intensity ${sample}`)\n                                .select((value) =>\n                                    // set to NaN if LFQ intensity is not\n                                    // positive\n                                    value > 0 ? Math.log2(value) : NaN\n                                ),\n                        }),\n                    {}\n                ),\n            },\n            index: this.data.getIndex(),\n        }).bake();\n    }\n\n    /**\n     * Modifies `data` to remove entries with NaN in all samples (i.e.\n     * intensity of 0 in all samples)\n     */\n    removeAllNaN() {\n        console.log(\"removing all NaN\");\n        this.data = this.data\n            // only keep rows where not every sample is NaN\n            .where(\n                (row) =>\n                    !this.samples.every((sample) =>\n                        isNaN(row[`LFQ intensity ${sample}`])\n                    )\n            )\n            .bake();\n\n        this.snapshots.set(MSExperiment.SNAPSHOT_KEYS.LOG_TRANSFORM, this.data);\n    }\n\n    /**\n     * Modifies `data` such that each sample is scaled to have the same median\n     * value, equal to the highest median pre-scaling.\n     */\n    normalizeMedians(normalize) {\n        console.log(\"normalizing medians\");\n\n        if (!normalize) {\n            this.snapshots.set(\n                MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION,\n                this.data\n            );\n            return;\n        }\n\n        // calculate medians of each sample and store in map\n        /** @type {Map<string, number>} */\n        const medians = new Map();\n        this.samples.map((sample) =>\n            medians.set(\n                sample,\n                this.data\n                    .getSeries(`LFQ intensity ${sample}`)\n                    .where((value) => !Number.isNaN(value))\n                    .median()\n            )\n        );\n        const maxMedian = Math.max.apply(null, Array.from(medians.values()));\n\n        this.data = new DataFrame({\n            columns: {\n                // copy common columns from current dataframe\n                ...MSExperiment.COMMON_COLUMNS.reduce(\n                    (obj, column) =>\n                        Object.assign(obj, {\n                            [column]: this.data.getSeries(column),\n                        }),\n                    {}\n                ),\n                // median normalize LFQ intensity columns\n                ...this.samples.reduce(\n                    (obj, sample) =>\n                        Object.assign(obj, {\n                            [`LFQ intensity ${sample}`]: this.data\n                                .getSeries(`LFQ intensity ${sample}`)\n                                .select(\n                                    // scale each sample intensity so that\n                                    // sample median matches the maximum sample\n                                    // median\n                                    (value) =>\n                                        (value * maxMedian) /\n                                        medians.get(sample)\n                                ),\n                        }),\n                    {}\n                ),\n            },\n            index: this.data.getIndex(),\n        }).bake();\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION,\n            this.data\n        );\n    }\n\n    /**\n     * Modifies `replicates` to store group replicate samples into conditions\n     * @param {Object.<string, string[]>} replicates object containing\n     * replicate data, where keys are condition names and values are arrays of\n     * sample names\n     */\n    setReplicates(replicates) {\n        this.replicates.clear();\n        for (const [condition, samples] of Object.entries(replicates))\n            this.replicates.set(condition, samples);\n    }\n\n    /**\n     * Modifies `data` to replace NA's (intensity of 0) with imputed values.\n     * Imputed values are drawn from a uniform distribution of log2 intensities\n     * ranging from -3 * sigma to -2 * sigma among non-NA log2 intensity\n     * values within the same sample.\n     */\n    imputeMissingValues(method) {\n        console.log(\"imputing missing values\");\n\n        switch (method) {\n            case MSExperiment.IMPUTATION_METHODS.METHOD_31:\n                this.data = Imputation.imputeUniform(this.data, this.samples);\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_46:\n                this.data = Imputation.imputeRelative(\n                    this.data,\n                    this.replicates\n                );\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_47:\n                this.data = Imputation.imputeRelative(\n                    this.data,\n                    this.replicates,\n                    1\n                );\n        }\n\n        this.snapshots.set(\n            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES,\n            this.data\n        );\n    }\n\n    /**\n     * Makes specified comparisons and stores results in `comparisons.\n     * @param {Object.<string, string[]>} comparisons object containing\n     * comparisons to make, with condition A as key and condition B in values\n     * array\n     * @param {number} thresholdP threshold adjusted p value to call a protein\n     * significant\n     * @param {number} thresholdLogFC threshold log2 fold change in intensity\n     * to call a protein significant\n     * @param {number} thresholdReps threshold number of replicates detected in\n     * the same condition to call a protein significant\n     */\n    makeComparisons(\n        comparisons,\n        { thresholdP = 0.05, thresholdLogFC = 1, thresholdReps = 2 } = {}\n    ) {\n        console.log(\"making comparisons\");\n        // loop through comparisons and set up `comparisons` map\n        for (const [conditionA, value] of Object.entries(comparisons)) {\n            if (!this.comparisons.has(conditionA))\n                this.comparisons.set(conditionA, new Map());\n\n            for (const conditionB of value) {\n                // subset relevant columns of raw data to count number of\n                // non-zero replicates later\n                const rawA = this.rawData.subset(\n                    this.replicates\n                        .get(conditionA)\n                        .map((sample) => `LFQ intensity ${sample}`)\n                );\n                const rawB = this.rawData.subset(\n                    this.replicates\n                        .get(conditionB)\n                        .map((sample) => `LFQ intensity ${sample}`)\n                );\n\n                const comparisonData = DataFrame.zip(\n                    [\n                        // for conditionA and conditionB, zip LFQ intensity columns\n                        // to make a column containing arrays of intensities from\n                        // replicates for that condition\n                        ...[conditionA, conditionB].map((condition) =>\n                            DataFrame.zip(\n                                this.replicates\n                                    .get(condition)\n                                    .map((sample) =>\n                                        this.data.getSeries(\n                                            `LFQ intensity ${sample}`\n                                        )\n                                    ),\n                                // zip multiple replicate columns into single\n                                // column containing array of values\n                                (values) => values.toArray()\n                            )\n                        ),\n                        // pass id as third item to zip\n                        this.data.subset([\"id\"]),\n                    ],\n                    // zip conditionA and conditionB columns of arrays arrA and\n                    // arrB\n                    ([arrA, arrB, { id: rowId }]) => {\n                        // calculate means of conditionA and conditionB\n                        // intensities\n                        const meanA = jstat(arrA).mean();\n                        const meanB = jstat(arrB).mean();\n                        // perform two-sample two-tailed t test (Welch) using\n                        // arrays of intensities to get p value\n                        const pvalue = ttest(arrA, arrB).p;\n\n                        // count number of replicates detected in raw data in\n                        // each condition\n                        const countNonzeroReps = (raw) =>\n                            Object.values(raw.at(rowId)).reduce((acc, val) => {\n                                if (Number(val) !== 0) acc++;\n                                return acc;\n                            }, 0);\n\n                        return {\n                            [`mean ${conditionA}`]: meanA,\n                            [`mean ${conditionB}`]: meanB,\n                            \"log FC\": meanB - meanA,\n                            \"p value\": pvalue,\n                            [`N ${conditionA}`]: countNonzeroReps(rawA),\n                            [`N ${conditionB}`]: countNonzeroReps(rawB),\n                        };\n                    }\n                )\n                    // copy common columns\n                    .withSeries(\n                        MSExperiment.COMMON_COLUMNS.reduce(\n                            (obj, column) =>\n                                Object.assign(obj, {\n                                    [column]: this.data.getSeries(column),\n                                }),\n                            {}\n                        )\n                    )\n                    .withIndex(this.data.getIndex())\n                    .bake()\n                    // calculate adjusted p value\n                    .withSeries({\n                        \"adjusted p value\": (df) =>\n                            new Series({\n                                index: df.getIndex(),\n                                values: pAdjust(\n                                    df.getSeries(\"p value\").toArray()\n                                ),\n                            }),\n                    })\n                    .bake()\n                    // check significance by p value, log FC, and replicates\n                    // detected\n                    .select((row) => {\n                        const output = { ...row };\n                        output[\"significant\"] =\n                            row[\"adjusted p value\"] <= thresholdP &&\n                            Math.abs(row[\"log FC\"]) >= thresholdLogFC &&\n                            (row[`N ${conditionA}`] >= thresholdReps ||\n                                row[`N ${conditionB}`] >= thresholdReps)\n                                ? \"yes\"\n                                : \"no\";\n                        return output;\n                    })\n                    .bake();\n\n                // put comparison dataframe into `comparisons` map\n                this.comparisons\n                    .get(conditionA)\n                    .set(conditionB, comparisonData);\n            }\n        }\n    }\n}\n\nexport default MSExperiment;\n","import worker from \"./AnalysisWorker\";\nimport MSExperiment from \"./analysis/MSExperiment\";\n\nexport const FIGURES = {\n    LOG_VIOLIN: \"LOG_VIOLIN\",\n    PRE_POST_IMPUTATION_VIOLIN: \"PRE_POST_IMPUTATION_VIOLIN\",\n    PRE_POST_IMPUTATION_BOXPLOT: \"PRE_POST_IMPUTATION_BOXPLOT\",\n    VOLCANO: \"VOLCANO\",\n    P_VALUE_HISTOGRAM: \"P_VALUE_HISTOGRAM\",\n};\n\nexport function makePlotCode(options) {\n    const { type } = options;\n    switch (type) {\n        case FIGURES.LOG_VIOLIN:\n            return makeLogViolin(options);\n        case FIGURES.PRE_POST_IMPUTATION_VIOLIN:\n            return makePrePostImputationViolin(options);\n        case FIGURES.VOLCANO:\n            return makeVolcanoPlot(options);\n        case FIGURES.P_VALUE_HISTOGRAM:\n            return makePValueHistogram(options);\n    }\n}\n\nexport async function makePlotlyDataLayout(options) {\n    const { type } = options;\n\n    let ret = { data: [], layout: {} };\n    switch (type) {\n        case FIGURES.LOG_VIOLIN:\n            ret = await makeLogViolin(options);\n            break;\n        case FIGURES.PRE_POST_IMPUTATION_VIOLIN:\n            ret = await makePrePostImputationViolin(options);\n            break;\n        case FIGURES.PRE_POST_IMPUTATION_BOXPLOT:\n            ret = await makePrePostImputationBoxplot(options);\n            break;\n        case FIGURES.VOLCANO:\n            ret = await makeVolcanoPlot(options);\n            break;\n        case FIGURES.P_VALUE_HISTOGRAM:\n            ret = await makePValueHistogram(options);\n            break;\n    }\n    ret.layout.autosize = true;\n\n    return ret;\n}\n\nfunction makeLogViolin({ samples, conditions }) {\n    let src = `\nfig, ax = reset()\ndata = await get_from_analysis(\"data\")\n    `;\n\n    if (samples != undefined && conditions == undefined) {\n        src += `\nsamples = [${samples.map((x) => `\"${x}\"`).join()}]\nx = data[lfq_col(samples)].values\nfiltered = [i[j] for i, j in zip(x.T, (~np.isnan(x)).T)]\n\nax.violinplot(filtered, vert=False)\nax.set_yticks(range(1, len(samples) + 1))\nax.set_yticklabels(samples)\nax.set_ylabel(\"sample\")\nax.set_title(\"distribution of protein intensities by sample\")\n        `;\n    } else if (samples == undefined && conditions != undefined) {\n        src += `\nconditions = [${conditions.map((x) => `\"${x}\"`).join()}]\nreplicates = await get_from_analysis(\"replicates\")\nx = [data[lfq_col(replicates[c])].values.flatten() for c in conditions]\nfiltered = [i[~np.isnan(i)] for i in x]\n\nax.violinplot(filtered, vert=False)\nax.set_yticks(range(1, len(conditions) + 1))\nax.set_yticklabels(conditions)\nax.set_ylabel(\"condition\")\nax.set_title(\"distribution of protein intensities by condition\")\n        `;\n    }\n\n    src += `\nax.set_xlabel(\"$\\\\log_2$ intensity\")\nax.invert_yaxis()\nplt.tight_layout()\nshow()\n    `;\n    return src;\n}\n\n/* async function makeLogViolin({ samples, conditions }) {\n    const makeViolinTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"violin\",\n            width: 1,\n            points: false,\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all(\n                samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.LOG_TRANSFORM\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                x: data,\n                                y0: sample,\n                                side: \"positive\",\n                            })\n                        )\n                )\n            ),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all(\n                conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                x: data,\n                                y0: condition,\n                                side: \"positive\",\n                            })\n                        )\n                )\n            ),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities\",\n        showlegend: false,\n        xaxis: {\n            title: \"log2 intensity\",\n        },\n        yaxis: {\n            automargin: true,\n        },\n    });\n    return ret;\n} */\n\nfunction makePrePostImputationViolin({ samples, conditions }) {\n    let src = `\nfig, ax = reset()\ndata = await get_from_analysis(\"data_normalized\")\nimputed = (await get_from_analysis(\"data_imputed\"))[0]\n    `;\n\n    if (samples != undefined && conditions == undefined) {\n        src += `\nsamples = [${samples.map((x) => `\"${x}\"`).join()}]\nx = data[lfq_col(samples)].values\nx_filtered = [i[j] for i, j in zip(x.T, (~np.isnan(x)).T)]\ny = imputed[lfq_col(samples)].values\ny_filtered = [i[j] for i, j in zip(y.T, (~np.isnan(y)).T)]\n\nv1 = ax.violinplot(x_filtered, vert=False)\nfor b in v1[\"bodies\"]:\n    center = np.mean(b.get_paths()[0].vertices[:,1])\n    b.get_paths()[0].vertices[:, 1] = np.clip(b.get_paths()[0].vertices[:,1], -np.inf, center)\n\nv2 = ax.violinplot(y_filtered, vert=False)\nfor b in v2[\"bodies\"]:\n    center = np.mean(b.get_paths()[0].vertices[:,1])\n    b.get_paths()[0].vertices[:, 1] = np.clip(b.get_paths()[0].vertices[:,1], center, np.inf)\n\nax.set_yticks(range(1, len(samples) + 1))\nax.set_yticklabels(samples)\nax.set_ylabel(\"sample\")\nax.set_title(\"distribution of protein intensities by sample\")\n        `;\n    } else if (samples == undefined && conditions != undefined) {\n        src += `\nconditions = [${conditions.map((x) => `\"${x}\"`).join()}]\nreplicates = await get_from_analysis(\"replicates\")\nx = [data[lfq_col(replicates[c])].values.flatten() for c in conditions]\nx_filtered = [i[~np.isnan(i)] for i in x]\ny = [imputed[lfq_col(replicates[c])].values.flatten() for c in conditions]\ny_filtered = [i[~np.isnan(i)] for i in y]\n\nv1 = ax.violinplot(x_filtered, vert=False)\nfor b in v1[\"bodies\"]:\n    center = np.mean(b.get_paths()[0].vertices[:,1])\n    b.get_paths()[0].vertices[:, 1] = np.clip(b.get_paths()[0].vertices[:,1], -np.inf, center)\n\nv2 = ax.violinplot(y_filtered, vert=False)\nfor b in v2[\"bodies\"]:\n    center = np.mean(b.get_paths()[0].vertices[:,1])\n    b.get_paths()[0].vertices[:, 1] = np.clip(b.get_paths()[0].vertices[:,1], center, np.inf)\n\nax.set_yticks(range(1, len(conditions) + 1))\nax.set_yticklabels(conditions)\nax.set_ylabel(\"condition\")\nax.set_title(\"distribution of protein intensities by condition\")\n        `;\n    }\n\n    src += `\nax.set_xlabel(\"$\\\\log_2$ intensity\")\nax.invert_yaxis()\nax.legend([v1[\"bodies\"][0], v2[\"bodies\"][0]], [\"pre-imputation\", \"post-imputation\"])\nplt.tight_layout()\nshow()\n    `;\n    return src;\n}\n\n/* async function makePrePostImputationViolin({ samples, conditions }) {\n    const makeViolinTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"violin\",\n            width: 1,\n            points: false,\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all([\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"pre\",\n                                x: data,\n                                y0: sample,\n                                legendgroup: \"pre\",\n                                side: \"positive\",\n                                line: {\n                                    color: \"#1f77b4\",\n                                },\n                            })\n                        )\n                ),\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES\n                        )\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"post\",\n                                x: data,\n                                y0: sample,\n                                legendgroup: \"post\",\n                                side: \"negative\",\n                                line: {\n                                    color: \"#ff7f0e\",\n                                },\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all([\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"pre\",\n                                x: data,\n                                y0: condition,\n                                legendgroup: \"pre\",\n                                side: \"positive\",\n                                line: {\n                                    color: \"#1f77b4\",\n                                },\n                            })\n                        )\n                ),\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .IMPUTE_MISSING_VALUES\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeViolinTrace({\n                                name: \"post\",\n                                x: data,\n                                y0: condition,\n                                legendgroup: \"post\",\n                                side: \"negative\",\n                                line: {\n                                    color: \"#ff7f0e\",\n                                },\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities pre- and post-imputation\",\n        xaxis: {\n            title: \"log2 intensity\",\n        },\n        yaxis: {\n            automargin: true,\n        },\n    });\n    return ret;\n} */\n\nasync function makePrePostImputationBoxplot({ samples, conditions }) {\n    const makeBoxplotTrace = (trace) => {\n        return Object.assign(trace, {\n            type: \"box\",\n        });\n    };\n\n    let ret = { data: [], layout: {} };\n    if (samples != undefined && conditions == undefined) {\n        ret = {\n            data: await Promise.all([\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.MEDIAN_NORMALIZATION\n                        )\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"pre\",\n                                y: data,\n                                x0: sample,\n                                legendgroup: \"pre\",\n                                marker: {\n                                    color: \"#1f77b4\",\n                                },\n                            })\n                        )\n                ),\n                ...samples.map((sample) =>\n                    worker\n                        .getData(\n                            `LFQ intensity ${sample}`,\n                            MSExperiment.SNAPSHOT_KEYS.IMPUTE_MISSING_VALUES\n                        )\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"post\",\n                                y: data,\n                                x0: sample,\n                                legendgroup: \"post\",\n                                marker: {\n                                    color: \"#ff7f0e\",\n                                },\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    } else if (samples == undefined && conditions != undefined) {\n        const replicates = await worker.getReplicates();\n        ret = {\n            data: await Promise.all([\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .MEDIAN_NORMALIZATION\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"pre\",\n                                y: data,\n                                x0: condition,\n                                legendgroup: \"pre\",\n                                marker: {\n                                    color: \"#1f77b4\",\n                                },\n                            })\n                        )\n                ),\n                ...conditions.map((condition) =>\n                    Promise.all(\n                        replicates\n                            .get(condition)\n                            .map((sample) =>\n                                worker.getData(\n                                    `LFQ intensity ${sample}`,\n                                    MSExperiment.SNAPSHOT_KEYS\n                                        .IMPUTE_MISSING_VALUES\n                                )\n                            )\n                    )\n                        .then((array) => array.flat())\n                        .then((data) =>\n                            makeBoxplotTrace({\n                                name: \"post\",\n                                y: data,\n                                x0: condition,\n                                legendgroup: \"post\",\n                                marker: {\n                                    color: \"#ff7f0e\",\n                                },\n                            })\n                        )\n                ),\n            ]),\n            layout: {},\n        };\n    }\n\n    Object.assign(ret.layout, {\n        title: \"log2 intensities pre- and post-imputation\",\n        xaxis: {\n            automargin: true,\n        },\n        yaxis: {\n            title: \"log2 intensity\",\n        },\n        boxmode: \"group\",\n        boxgap: -1,\n        boxgroupgap: 0,\n    });\n    return ret;\n}\n\nfunction makeVolcanoPlot({ comparisons, highlightGenes }) {\n    return `\nfig, ax = reset()\ndata = await get_from_analysis(\"data_comparisons\")\ntable = data[(\"${comparisons[0]}\", \"${comparisons[1]}\")]\n\ngenes = [${(highlightGenes || []).map((g) => `\"${g}\"`).join(\",\\n    \")}]\n\nproteomics.plotting.volcano(table, [\n    (set(table.index), {\"color\": \"gray\", \"alpha\": 0.1, \"label\": \"_nolegend_\"}, None),\n    (set(table[table[\"significant\"]].index), {\"color\": \"darkred\", \"alpha\": 0.1, \"label\": \"significant\"}, None),\n    (set(genes), {\"color\": \"tab:blue\", \"alpha\": 0.8, \"label\": \"_nolegend_\"}, \"gene\")\n], ax=ax, interactive=True)\n\nax.set_xlabel(\"$\\\\log_2$ fold change\")\nax.set_ylabel(\"$-\\\\log_{10} \\\\; p_{adjusted}$\")\nax.set_title(\"${comparisons[1]} vs. ${comparisons[0]}\")\nax.legend()\nplt.tight_layout()\nshow()\n    `;\n}\n\n/* async function makeVolcanoPlot({ comparisons, highlightGenes }) {\n    if (!comparisons) return { data: [], layout: {} };\n    const highlightGeneSet = new Set(\n        (highlightGenes || []).map((g) => g.toLowerCase())\n    );\n    return {\n        data: [\n            await Promise.all([\n                worker.getComparisonData(comparisons, \"log FC\"),\n                worker.getComparisonData(comparisons, \"adjusted p value\"),\n                worker.getComparisonData(comparisons, \"gene\"),\n                worker.getComparisonData(comparisons, \"significant\"),\n            ]).then(([logfc, pvalues, genes, significant]) => {\n                return {\n                    type: \"scattergl\",\n                    mode: \"markers\",\n                    x: logfc,\n                    y: pvalues.map((p) => -1 * Math.log10(p)),\n                    hovertext: genes,\n                    marker: {\n                        color:\n                            highlightGeneSet.size === 0\n                                ? significant.map((sig) =>\n                                      sig === \"yes\" ? 1 : 0\n                                  )\n                                : genes.map((g) =>\n                                      highlightGeneSet.has(g.toLowerCase())\n                                          ? 1\n                                          : 0\n                                  ),\n                    },\n                };\n            }),\n        ],\n        layout: {\n            title: `${comparisons[1]} vs. ${comparisons[0]}`,\n            xaxis: {\n                title: `log2 (${comparisons[1]} / ${comparisons[0]})`,\n            },\n            yaxis: {\n                title: \"-log10 (p_adjusted)\",\n            },\n        },\n    };\n} */\n\nfunction makePValueHistogram({ comparisons }) {\n    return `\nfig, ax = reset()\ndata = await get_from_analysis(\"data_comparisons\")\ntable = data[(\"${comparisons[0]}\", \"${comparisons[1]}\")]\n\nax.hist(table[\"p\"], bins=40, alpha=0.5, label=\"$p$-value\")\nax.hist(table[\"p adjusted\"], bins=40, alpha=0.5, label=\"adjusted $p$-value\")\nax.set_xlabel(\"$p$\")\nax.set_ylabel(\"Count\")\nax.set_title(\"distribution of $p$-values for ${comparisons[1]} vs. ${comparisons[0]}\")\nax.legend()\nplt.tight_layout()\nshow()\n    `;\n}\n\n/* async function makePValueHistogram({ comparisons }) {\n    if (!comparisons) return { data: [], layout: {} };\n    return {\n        data: [\n            {\n                type: \"histogram\",\n                name: \"p value\",\n                x: await worker.getComparisonData(comparisons, \"p value\"),\n                opacity: 0.5,\n                xbins: {\n                    start: 0,\n                    end: 1,\n                    size: 0.025,\n                },\n            },\n            {\n                type: \"histogram\",\n                name: \"adjusted p value\",\n                x: await worker.getComparisonData(\n                    comparisons,\n                    \"adjusted p value\"\n                ),\n                opacity: 0.5,\n                xbins: {\n                    start: 0,\n                    end: 1,\n                    size: 0.025,\n                },\n            },\n        ],\n        layout: {\n            title: `${comparisons[1]} vs. ${comparisons[0]} p values`,\n            barmode: \"overlay\",\n            xaxis: {\n                title: \"p\",\n            },\n            yaxis: {\n                title: \"count\",\n            },\n        },\n    };\n} */\n","import worker from \"./AnalysisWorker\";\nimport { ACTIONS, createAction } from \"./store/actions\";\nimport Plotly from \"plotly.js\";\n\nimport { runPython, runPythonWorker, getPythonWorker } from \"./PyAnalysis\";\nimport { makePlotCode } from \"./Figures\";\nimport MSExperiment from \"./analysis/MSExperiment\";\n\n/**\n * This file interfaces between UI and analysis. UI changes are handled on the\n * main thread (this file) while analysis is handled in a worker (see\n * worker.js); each function calls the equivalent function in the worker, via\n * comlink proxy, to handle the analysis aspect off of the main thread.\n */\n\nexport function onDataUpload(file) {\n    return (dispatch) => {\n        new Response(file)\n            // wrap file blob in response to read data as array buffer\n            .arrayBuffer()\n            // transfer array buffer to worker python instance to import as\n            // maxquant file\n            .then((ab) =>\n                runPythonWorker(\n                    `\nfrom js import raw_data\nimport io\n\ndata, samples = proteomics.io.import_maxquant(\n    io.BytesIO(raw_data.to_py()),\n    normalize=False\n)\nprint(data)\nprint(samples)\n                    `,\n                    {\n                        raw_data: ab,\n                    },\n                    [ab]\n                )\n            )\n            // get \"samples\" variable from worker python instance\n            .then(() => getPythonWorker(\"samples\"))\n            // update UI with sample names\n            .then((samples) => {\n                dispatch(createAction(ACTIONS.SET_INPUT_SAMPLES, samples));\n            });\n    };\n}\n\nexport function onReplicatesSelect(conditions) {\n    return (dispatch) => {\n        // set replicates dictionary on analysis thread\n        runPythonWorker(\n            `\nreplicates = {\n${Object.entries(conditions)\n    .map(\n        ([condition, samples]) =>\n            `    \"${condition}\": [${samples.map((x) => `\"${x}\"`)}]`\n    )\n    .join(\",\\n\")}\n}\n            `\n        ).then(() => {\n            // update UI with condition names\n            dispatch(\n                createAction(\n                    ACTIONS.SET_INPUT_CONDITIONS,\n                    Object.keys(conditions)\n                )\n            );\n        });\n    };\n}\n\nexport function onImpute(options) {\n    return (dispatch) => {\n        const { normalize, method } = options;\n        let src = \"\";\n        if (normalize)\n            src += `\ndata_normalized = data.copy()\nmax_median = data[lfq_col(samples)].median(axis=0).max()\ndata_normalized[lfq_col(samples)] = data_normalized[lfq_col(samples)].apply(\n    lambda col: col * max_median / col.median(), axis=0\n)\n            `;\n        else\n            src += `\ndata_normalized = data.copy()\n            `;\n\n        src += `\ndata_imputed = []\nfor i in range(1):\n    df = data_normalized.copy()\n    for cond, reps in replicates.items():\n        `;\n        switch (method) {\n            case MSExperiment.IMPUTATION_METHODS.METHOD_31:\n                src += `\n        df[lfq_col(reps)] = proteomics.imputation.impute_3_1(df[lfq_col(reps)])\n                `;\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_46:\n                src += `\n        df[lfq_col(reps)] = proteomics.imputation.impute_twostep(\n            proteomics.imputation.impute_4_6(df[lfq_col(reps)]),\n            proteomics.imputation.impute_3_1(df[lfq_col(reps)])\n        )\n                `;\n                break;\n            case MSExperiment.IMPUTATION_METHODS.METHOD_47:\n                src += `\n        df[lfq_col(reps)] = proteomics.imputation.impute_twostep(\n            proteomics.imputation.impute_4_6(df[lfq_col(reps)], n_rep=1),\n            proteomics.imputation.impute_3_1(df[lfq_col(reps)])\n        )\n                `;\n                break;\n        }\n\n        src += `\n        data_imputed.append(df)\n        `;\n        runPythonWorker(src);\n    };\n}\n\nexport function onComparisonsSelect(comparisons, thresholds) {\n    return (dispatch) => {\n        let src = `\ncomparisons = [\n${Object.entries(comparisons)\n    .map(([a, listb]) => listb.map((b) => `    (\"${a}\", \"${b}\"),`))\n    .flat()\n    .join(\"\\n\")}\n]\n\ndata_comparisons = proteomics.imputation.compare(\n    comparisons, \n    replicates, \n    data_normalized,\n    data_imputed,\n    sig_p=${thresholds.thresholdP},\n    sig_fc=${thresholds.thresholdLogFC},\n    sig_reps=${thresholds.thresholdReps}\n)\n        `;\n        runPythonWorker(src).then(() => {\n            dispatch(createAction(ACTIONS.SET_INPUT_COMPARISONS, comparisons));\n        });\n    };\n}\n\nexport function showPlot(figureOptions) {\n    return (dispatch) => {\n        let src = makePlotCode(figureOptions);\n        runPython(src);\n    };\n}\n\nexport function getComparisonTable(comparison) {\n    // convert dataframe to list of dicts\n    return runPythonWorker(`\ntable = data_comparisons[(\"${comparison[0]}\", \"${comparison[1]}\")].fillna(\"\").assign(significant=lambda df: df[\"significant\"].apply(str)).to_dict(\"records\")\n        `)\n        .then(() => {\n            // retrieve comparison data from worker python instance\n            return getPythonWorker(\"table\");\n        })\n        .then((table) => {\n            // pyodide converts dict to map; convert maps to objects\n            return table.map((row) => Object.fromEntries(row));\n        });\n}\n\nexport function downloadData() {\n    return (dispatch) => {\n        // get bytes to save as excel file from worker\n        worker.downloadData().then((data) => {\n            // make new blob and link pointing to blob, click to save file\n            const blob = new Blob([data], { type: \"application/vnd.ms-excel\" });\n            const link = document.createElement(\"a\");\n            link.href = window.URL.createObjectURL(blob);\n            link.download = \"results.xlsx\";\n            link.click();\n        });\n    };\n}\n","import { connect } from \"react-redux\";\nimport { onDataUpload } from \"../RunAnalysis\";\n\nfunction InputDataUpload({ onDataUpload }) {\n    return (\n        <div>\n            <label htmlFor=\"dataUpload\">\n                (1) Select data to begin analysis:{\" \"}\n            </label>\n            <input\n                type=\"file\"\n                id=\"dataUpload\"\n                name=\"dataUpload\"\n                onInput={(e) => onDataUpload(e.target.files[0])}\n            />\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions per sample as\n                    violin plot or boxplot.\n                </li>\n            </ul>\n        </div>\n    );\n}\n\nexport default connect(null, (dispatch) => {\n    return {\n        onDataUpload: (file) => {\n            dispatch(onDataUpload(file));\n        },\n    };\n})(InputDataUpload);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputReplicateSelection.css\";\nimport { onReplicatesSelect } from \"../RunAnalysis\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputReplicateSelection({ samples, onReplicatesSelect }) {\n    const [replicatesModalOpen, setReplicatesModalOpen] = React.useState(false);\n    const [selectedReplicates, setSelectedReplicates] = React.useState([]);\n    const [conditionName, setConditionName] = React.useState(\"\");\n    const [conditions, setConditions] = React.useState({});\n\n    const onAddCondition = () => {\n        if (conditionName.length === 0) return;\n        setConditions(\n            Object.assign({}, conditions, {\n                [conditionName]: selectedReplicates,\n            })\n        );\n        setConditionName(\"\");\n    };\n\n    const onOKClick = () => {\n        onReplicatesSelect(conditions);\n        setReplicatesModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(2) </span>\n            <button onClick={() => setReplicatesModalOpen(true)}>\n                Select replicates\n            </button>\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions per condition\n                    as violin plot or boxplot.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={replicatesModalOpen}\n                id=\"input-replicate-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-replicate-modal-head\">Select replicates</h1>\n\n                <div id=\"input-replicate-modal-left\">\n                    <p>Samples present in data:</p>\n                    <select\n                        multiple\n                        onChange={(e) => {\n                            setSelectedReplicates(\n                                Array.from(e.target.selectedOptions).map(\n                                    (opt) => opt.value\n                                )\n                            );\n                        }}\n                    >\n                        {samples.map((sample) => (\n                            <option value={sample} key={sample}>\n                                {sample}\n                            </option>\n                        ))}\n                    </select>\n                </div>\n\n                <div>\n                    <p>New condition wtih selected samples as replicates:</p>\n                    <label htmlFor=\"conditionName\">Condition name: </label>\n                    <input\n                        type=\"text\"\n                        id=\"conditionName\"\n                        name=\"conditionName\"\n                        value={conditionName}\n                        onChange={(e) => setConditionName(e.target.value)}\n                    />\n                    <br />\n                    <button onClick={onAddCondition}>Add condition</button>\n                    <br />\n                    <hr style={{ margin: \"2rem\" }} />\n                    <button onClick={() => setConditions({})}>\n                        Reset conditions\n                    </button>\n                </div>\n\n                <div id=\"input-replicate-modal-right\">\n                    <p>Conditions and replicates:</p>\n                    <div>\n                        {Object.entries(conditions).map(\n                            ([condition, replicates]) => (\n                                <p key={condition}>\n                                    {condition}: {replicates.join(\", \")}\n                                </p>\n                            )\n                        )}\n                    </div>\n                </div>\n\n                <div id=\"input-replicate-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {\n            samples: state.input.samples,\n        };\n    },\n    (dispatch) => {\n        return {\n            onReplicatesSelect: (conditions) => {\n                dispatch(onReplicatesSelect(conditions));\n            },\n        };\n    }\n)(InputReplicateSelection);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputImputation.css\";\nimport { onImpute } from \"../RunAnalysis\";\nimport MSExperiment from \"../analysis/MSExperiment\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputImputation({ onImputeClick }) {\n    const [imputationModalOpen, setImputationModalOpen] = React.useState(false);\n    const [options, setOptions] = React.useState({\n        normalize: true,\n        method: MSExperiment.IMPUTATION_METHODS.METHOD_31,\n    });\n\n    const onOKClick = () => {\n        onImputeClick(options);\n        setImputationModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(3) </span>\n            <button onClick={() => setImputationModalOpen(true)}>\n                Preprocess and impute\n            </button>\n\n            <ul>\n                <li>\n                    View log-transformed intensity distributions before and\n                    after imputation as violin plot or boxplot.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={imputationModalOpen}\n                id=\"input-imputation-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-imputation-modal-head\">Imputation options</h1>\n\n                <div id=\"input-imputation-modal-body\">\n                    <h2>Pre-processing</h2>\n                    <input\n                        type=\"checkbox\"\n                        id=\"normalizeMedians\"\n                        checked={options.normalize}\n                        onChange={(e) =>\n                            setOptions(\n                                Object.assign({}, options, {\n                                    normalize: e.target.checked,\n                                })\n                            )\n                        }\n                    />\n                    <label htmlFor=\"normalizeMedians\">Normalize medians</label>\n                    <h2>Imputation</h2>\n                    <select\n                        onChange={(e) =>\n                            setOptions(\n                                Object.assign({}, options, {\n                                    method: e.currentTarget.value,\n                                })\n                            )\n                        }\n                    >\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_31}\n                        >\n                            method 3.1\n                        </option>\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_46}\n                        >\n                            method 4.6\n                        </option>\n                        <option\n                            value={MSExperiment.IMPUTATION_METHODS.METHOD_47}\n                        >\n                            method 4.7\n                        </option>\n                    </select>\n                </div>\n\n                <div id=\"input-replicate-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {};\n    },\n    (dispatch) => {\n        return {\n            onImputeClick: (options) => {\n                dispatch(onImpute(options));\n            },\n        };\n    }\n)(InputImputation);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport Modal from \"react-modal\";\n\nimport \"./InputComparisonSelection.css\";\nimport { onComparisonsSelect } from \"../RunAnalysis\";\n\nModal.setAppElement(\"#root\");\n\nfunction InputComparisonSelection({ conditions, onComparisonSelect }) {\n    const [comparisonModalOpen, setComparisonModalOpen] = React.useState(false);\n\n    const [thresholdP, setThresholdP] = React.useState(0.05);\n    const [thresholdLogFC, setThresholdLogFC] = React.useState(1);\n    const [thresholdReps, setThresholdReps] = React.useState(2);\n\n    /** @type {Map.<string, Set<string>} */\n    const [comparisons, setComparisons] = React.useState({});\n\n    const onComparisonChange = (conditionA, conditionB, selected) => {\n        let cpy = { ...comparisons };\n        if (selected) {\n            cpy[conditionA] = [...(cpy[conditionA] || [])];\n            if (!cpy[conditionA].includes(conditionB))\n                cpy[conditionA].push(conditionB);\n        } else {\n            if (conditionA in cpy && cpy[conditionA].includes(conditionB)) {\n                cpy[conditionA] = [...cpy[conditionA]].splice(\n                    cpy[conditionA].indexOf(conditionB),\n                    1\n                );\n            }\n        }\n        setComparisons(cpy);\n    };\n\n    const onOKClick = () => {\n        onComparisonSelect(comparisons, {\n            thresholdP,\n            thresholdLogFC,\n            thresholdReps,\n        });\n        setComparisonModalOpen(false);\n    };\n\n    return (\n        <div>\n            <span>(4) </span>\n            <button onClick={() => setComparisonModalOpen(true)}>\n                Select comparisons\n            </button>\n\n            <ul>\n                <li>\n                    View enriched and depleted proteins per comparison as\n                    volcano plot.\n                </li>\n                <li>View distribution of p values and adjusted p values.</li>\n                <li>\n                    View mean intensities, log fold changes, p values as data\n                    table.\n                </li>\n            </ul>\n\n            <Modal\n                isOpen={comparisonModalOpen}\n                id=\"input-comparison-modal\"\n                style={{\n                    overlay: {\n                        zIndex: 1000,\n                    },\n                }}\n            >\n                <h1 id=\"input-comparison-modal-head\">Select comparisons</h1>\n\n                <table>\n                    <tbody>\n                        <tr>\n                            <td></td>\n                            {conditions.map((condition) => (\n                                <td key={`${condition} B`}>{condition}</td>\n                            ))}\n                        </tr>\n                        {conditions.map((conditionA) => (\n                            <tr key={`${conditionA} row`}>\n                                <td key={`${conditionA} A`}>{conditionA}</td>\n                                {conditions.map((conditionB) => (\n                                    <td key={`${conditionA},${conditionB}`}>\n                                        <input\n                                            type=\"checkbox\"\n                                            onChange={(e) =>\n                                                onComparisonChange(\n                                                    conditionA,\n                                                    conditionB,\n                                                    e.target.checked\n                                                )\n                                            }\n                                            disabled={conditionA === conditionB}\n                                        />\n                                    </td>\n                                ))}\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n\n                <div>\n                    <label htmlFor=\"threshold-p\">Significant p-value: </label>\n                    <input\n                        type=\"number\"\n                        step=\"any\"\n                        min={0}\n                        value={thresholdP}\n                        onChange={(e) => setThresholdP(e.target.value)}\n                        id=\"threshold-p\"\n                    />\n                    <br />\n                    <label htmlFor=\"threshold-logfc\">\n                        Significant log fold change:{\" \"}\n                    </label>\n                    <input\n                        type=\"number\"\n                        step=\"any\"\n                        min={0}\n                        value={thresholdLogFC}\n                        onChange={(e) => setThresholdLogFC(e.target.value)}\n                        id=\"threshold-logfc\"\n                    />\n                    <br />\n                    <label htmlFor=\"threshold-reps\">\n                        Significant number of replicates:{\" \"}\n                    </label>\n                    <input\n                        type=\"number\"\n                        step={1}\n                        min={0}\n                        value={thresholdReps}\n                        onChange={(e) => setThresholdReps(e.target.value)}\n                        id=\"threshold-reps\"\n                    />\n                </div>\n\n                <div id=\"input-comparison-modal-foot\">\n                    <button onClick={onOKClick}>OK</button>\n                </div>\n            </Modal>\n        </div>\n    );\n}\n\nexport default connect(\n    (state) => {\n        return {\n            conditions: state.input.conditions,\n        };\n    },\n    (dispatch) => {\n        return {\n            onComparisonSelect: (comparisons, thresholds) => {\n                dispatch(onComparisonsSelect(comparisons, thresholds));\n            },\n        };\n    }\n)(InputComparisonSelection);\n","import \"./InputContainer.css\";\nimport InputDataUpload from \"./InputDataUpload\";\nimport InputReplicateSelection from \"./InputReplicateSelection\";\nimport InputImputation from \"./InputImputation\";\nimport InputComparisonSelection from \"./InputComparisonSelection\";\n\nfunction InputContainer({ id }) {\n    return (\n        <div id={id} className=\"input-container\">\n            <InputDataUpload />\n            <InputReplicateSelection />\n            <InputImputation />\n            <InputComparisonSelection />\n        </div>\n    );\n}\n\nexport default InputContainer;\n","export default __webpack_public_path__ + \"static/media/init_figure.ba7bfc03.py\";","import React from \"react\";\nimport Plot from \"react-plotly.js\";\nimport { connect } from \"react-redux\";\nimport { makePlotlyDataLayout } from \"../Figures\";\n\nimport { ready, py } from \"../PyAnalysis\";\nimport initFigure from \"../python/init_figure.py\";\n\nclass MainPanelContainer extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            content: \"Loading...\",\n        };\n    }\n\n    componentDidMount() {\n        ready\n            .then(() => fetch(initFigure))\n            .then((res) => res.text())\n            .then((src) => py().runPythonAsync(src))\n            .then(() => {\n                this.setState({\n                    content: null,\n                });\n            });\n    }\n\n    render() {\n        const { id } = this.props;\n\n        return (\n            <div id={id}>\n                {this.state.content}\n                <div id=\"figure-div\"></div>\n            </div>\n        );\n    }\n}\n\nexport default connect((state) => {\n    return {\n        // figureOptions: state.view.figureOptions,\n    };\n}, null)(MainPanelContainer);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./ReplOutput.css\";\n\nfunction ReplOutput({ index, context, code, results, error }) {\n    return (\n        <div className=\"repl-block\">\n            <span>\n                [{index}]: {context}\n            </span>\n            <pre className=\"repl-code\">{code}</pre>\n            {results ? <pre className=\"repl-results\">{results}</pre> : null}\n            {error ? <pre className=\"repl-error\">{error}</pre> : null}\n        </div>\n    );\n}\n\nexport default connect(null, null)(ReplOutput);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport worker from \"../AnalysisWorker\";\n\nimport \"./SidePanelContainer.css\";\n\nimport MUIDataTable from \"mui-datatables\";\nimport ReplOutput from \"./ReplOutput\";\nimport { getComparisonTable } from \"../RunAnalysis\";\nimport { runPython, runPythonWorker } from \"../PyAnalysis\";\n\nfunction SidePanelContainer({ id, samples, figureOptions, replLog }) {\n    const [tab, setTab] = React.useState(\"table\");\n    const [data, setData] = React.useState();\n    const [code, setCode] = React.useState(\"\");\n\n    React.useEffect(async () => {\n        if (figureOptions.comparisons) {\n            getComparisonTable(figureOptions.comparisons).then((table) => {\n                setData(table);\n            });\n        }\n    }, [figureOptions.comparisons]);\n\n    let content;\n    switch (tab) {\n        case \"table\":\n            content = (\n                <MUIDataTable\n                    title={\n                        figureOptions.comparisons\n                            ? `${figureOptions.comparisons[1]} vs. ${figureOptions.comparisons[0]}`\n                            : \"\"\n                    }\n                    data={data}\n                    columns={data ? Object.keys(data[0]) : []}\n                    options={{\n                        selectableRows: \"none\",\n                    }}\n                />\n            );\n            break;\n        case \"repl\":\n            content = (\n                <div className=\"repl\">\n                    <div className=\"repl-output\">\n                        {replLog.map((log) => (\n                            <ReplOutput\n                                key={log.index}\n                                index={log.index}\n                                context={log.context}\n                                code={log.code}\n                                results={log.results}\n                                error={log.error}\n                            ></ReplOutput>\n                        ))}\n                    </div>\n                    <div className=\"repl-input\">\n                        <textarea\n                            className=\"repl-inputbox\"\n                            rows={5}\n                            value={code}\n                            onChange={(e) => setCode(e.target.value)}\n                        ></textarea>\n                        <div className=\"repl-inputrun\">\n                            <button\n                                className=\"repl-runworker\"\n                                onClick={() => runPythonWorker(code)}\n                            >\n                                run in worker\n                            </button>\n                            <button\n                                className=\"repl-runfigure\"\n                                onClick={() => runPython(code)}\n                            >\n                                run in figure\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            );\n            break;\n    }\n\n    return (\n        <div id={id} className=\"sidepanel-container\">\n            <div className=\"sidepanel-top\">{content}</div>\n            <div className=\"sidepanel-bottom\">\n                <span\n                    className={\"tab\" + (tab === \"table\" ? \" tab-selected\" : \"\")}\n                    onClick={() => setTab(\"table\")}\n                >\n                    table\n                </span>\n                <span\n                    className={\"tab\" + (tab === \"repl\" ? \" tab-selected\" : \"\")}\n                    onClick={() => setTab(\"repl\")}\n                >\n                    REPL\n                </span>\n            </div>\n        </div>\n    );\n}\n\nexport default connect((state) => {\n    return {\n        figureOptions: state.view.figureOptions,\n        replLog: state.repl,\n    };\n}, null)(SidePanelContainer);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { FIGURES } from \"../Figures\";\n\nimport \"./FigureOptions.css\";\n\nfunction FigureOptions({\n    samples,\n    conditions,\n    comparisons,\n    figureType,\n    onOptionsChange,\n}) {\n    const [sampleCondition, setSampleCondition] = React.useState(\"samples\");\n\n    let options;\n    switch (figureType) {\n        case FIGURES.LOG_VIOLIN:\n        case FIGURES.PRE_POST_IMPUTATION_VIOLIN:\n        case FIGURES.PRE_POST_IMPUTATION_BOXPLOT:\n            const onFigureTypeChange = (e) => {\n                setSampleCondition(e.currentTarget.value);\n                onOptionsChange({\n                    samples: undefined,\n                    conditions: undefined,\n                });\n            };\n\n            options = (\n                <>\n                    <div>\n                        <input\n                            type=\"radio\"\n                            id=\"figureTypeSamples\"\n                            name=\"figureType\"\n                            value=\"samples\"\n                            checked={sampleCondition === \"samples\"}\n                            onChange={onFigureTypeChange}\n                        />\n                        <label htmlFor=\"figureTypeSamples\">Samples</label>\n                        <br />\n                        <input\n                            type=\"radio\"\n                            id=\"figureTypeConditions\"\n                            name=\"figureType\"\n                            value=\"conditions\"\n                            checked={sampleCondition === \"conditions\"}\n                            onChange={onFigureTypeChange}\n                        />\n                        <label htmlFor=\"figureTypeConditions\">Conditions</label>\n                    </div>\n                    <select\n                        className=\"sample-condition-selector\"\n                        multiple\n                        onChange={(e) => {\n                            onOptionsChange({\n                                [sampleCondition]: Array.from(\n                                    e.target.selectedOptions\n                                ).map((opt) => opt.value),\n                            });\n                        }}\n                    >\n                        {{ samples, conditions }[sampleCondition].map(\n                            (name) => (\n                                <option value={name} key={name}>\n                                    {name}\n                                </option>\n                            )\n                        )}\n                    </select>\n                </>\n            );\n            break;\n        case FIGURES.VOLCANO:\n        case FIGURES.P_VALUE_HISTOGRAM:\n            options = (\n                <>\n                    <select\n                        className=\"comparison-selector\"\n                        multiple\n                        onChange={(e) => {\n                            onOptionsChange({\n                                comparisons: JSON.parse(e.target.value),\n                            });\n                        }}\n                    >\n                        {Object.entries(comparisons || {})\n                            .map(([conditionA, value]) =>\n                                value.map((conditionB) => (\n                                    <option\n                                        value={JSON.stringify([\n                                            conditionA,\n                                            conditionB,\n                                        ])}\n                                        key={JSON.stringify([\n                                            conditionA,\n                                            conditionB,\n                                        ])}\n                                    >\n                                        {conditionB} vs. {conditionA}\n                                    </option>\n                                ))\n                            )\n                            .flat()}\n                    </select>\n                    <textarea\n                        className=\"highlight-genes-textbox\"\n                        placeholder=\"highlight genes in volcano plot (case insensitive); one gene per line\"\n                        onChange={(e) =>\n                            onOptionsChange({\n                                highlightGenes: e.target.value\n                                    .split(\"\\n\")\n                                    .filter((g) => g !== \"\"),\n                            })\n                        }\n                    ></textarea>\n                </>\n            );\n            break;\n    }\n\n    return <div className=\"figure-sample-condition-selector\">{options}</div>;\n}\n\nexport default connect((state) => {\n    return {\n        samples: state.input.samples,\n        conditions: state.input.conditions,\n        comparisons: state.input.comparisons,\n    };\n}, null)(FigureOptions);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { FIGURES } from \"../Figures\";\nimport { showPlot } from \"../RunAnalysis\";\nimport { ACTIONS, createAction } from \"../store/actions\";\n\nimport FigureOptions from \"./FigureOptions\";\n\nimport \"./ViewContainer.css\";\n\nfunction ViewContainer({ id, onOptionsSet }) {\n    const [figureOptions, setFigureOptions] = React.useState({});\n\n    return (\n        <div id={id} className=\"view-container\">\n            <p>Select data to view.</p>\n            <div className=\"figure-options\">\n                {/* select figure type */}\n                <select\n                    onChange={(e) => {\n                        setFigureOptions(\n                            Object.assign({}, figureOptions, {\n                                type: e.target.value,\n                            })\n                        );\n                    }}\n                    defaultValue=\"default\"\n                >\n                    {[\n                        <option disabled value=\"default\" key=\"default\">\n                            -- select an option --\n                        </option>,\n                        ...Object.keys(FIGURES).map((fig) => (\n                            <option value={fig} key={fig}>\n                                {fig}\n                            </option>\n                        )),\n                    ]}\n                </select>\n\n                {/* select figure options */}\n                <FigureOptions\n                    figureType={figureOptions.type}\n                    onOptionsChange={(changedOptions) =>\n                        setFigureOptions(\n                            Object.assign({}, figureOptions, changedOptions)\n                        )\n                    }\n                />\n\n                {/* set options */}\n                <button onClick={() => onOptionsSet(figureOptions)}>\n                    View data\n                </button>\n            </div>\n        </div>\n    );\n}\n\nexport default connect(null, (dispatch) => {\n    return {\n        onOptionsSet: (figureOptions) => {\n            dispatch(showPlot(figureOptions));\n            dispatch(\n                createAction(ACTIONS.SET_VIEW_FIGURE_OPTIONS, figureOptions)\n            );\n        },\n    };\n})(ViewContainer);\n","import \"./App.css\";\nimport InputContainer from \"./InputContainer\";\nimport MainPanelContainer from \"./MainPanelContainer\";\nimport SidePanelContainer from \"./SidePanelContainer\";\nimport ViewContainer from \"./ViewContainer.js\";\n\nfunction App() {\n    return (\n        <div id=\"app-container\">\n            <InputContainer id=\"input-container\" />\n            <ViewContainer id=\"view-container\" />\n            <SidePanelContainer id=\"sidepanel-container\" />\n            <MainPanelContainer id=\"mainpanel-container\" />\n        </div>\n    );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"font-awesome/css/font-awesome.min.css\";\nimport App from \"./components/App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport store from \"./store/store\";\nimport { Provider } from \"react-redux\";\n\nimport \"./PyAnalysis\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <Provider store={store}>\n            <App />\n        </Provider>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals(console.log);\n"],"sourceRoot":""}